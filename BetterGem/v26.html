<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BetterGem AI Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #94a3b8; /* slate-400 */
            border-radius: 4px;
        }
        html.dark ::-webkit-scrollbar-thumb {
            background-color: #475569; /* slate-600 */
        }
        ::-webkit-scrollbar-track {
            background-color: #f1f5f9; /* slate-100 */
        }
        html.dark ::-webkit-scrollbar-track {
            background-color: #1e293b; /* slate-800 */
        }

        /* Chat bubble styles - Removed hardcoded colors to rely on Tailwind */
        .chat-bubble {
            max-width: 75%;
            padding: 10px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            word-wrap: break-word;
            transition: background-color 0.3s, color 0.3s;
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .user-bubble {
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        .ai-bubble {
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        /* System message bubble style */
        .system-bubble {
            text-align: center;
            font-size: 0.875rem; /* text-sm */
            color: #64748b; /* slate-500 */
            width: 100%;
            max-width: 100%;
            background-color: transparent;
            box-shadow: none;
            margin-left: 0;
            margin-right: 0;
            padding: 5px 0;
        }

        /* Message delete button */
        .delete-message-button {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* text-xs */
            cursor: pointer;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease-in-out;
        }
        .chat-bubble:hover .delete-message-button {
            opacity: 1; /* Show on hover */
        }
        .delete-message-button:hover {
            background-color: rgba(255, 0, 0, 1);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            margin: auto;
            padding: 20px;
            border: 1px solid #888; /* Fallback border */
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .close-button {
            float: right;
            font-size: 28px;
            font-weight: bold;
            transition: color 0.3s;
        }
        .close-button:hover,
        .close-button:focus {
            text-decoration: none;
            cursor: pointer;
        }
        /* Active states for buttons */
        .mic-active svg, .speaker-active svg, .screen-sharing-active svg, .deep-research-active svg, .canvas-active svg {
            color: #ef4444; /* red-500 */
        }
        html.dark .mic-active svg, html.dark .speaker-active svg, html.dark .screen-sharing-active svg, html.dark .deep-research-active svg, html.dark .canvas-active svg {
             color: #f87171; /* red-400 */
        }
        /* Image generation toggle active state */
        .image-gen-active svg { /* Target the SVG directly */
            color: #ef4444; /* red-500 */
        }
        html.dark .image-gen-active svg {
            color: #f87171; /* red-400 */
        }

        /* Voice select dropdown width */
        #voice-select-dropdown {
            max-width: 150px; /* Limit width of voice selector */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Chat list item active state */
        .chat-list-item.active {
            background-color: #e2e8f0; /* slate-200 */
            font-weight: 600; /* font-semibold */
        }
        html.dark .chat-list-item.active {
            background-color: #334155; /* slate-700 */
        }

        /* Ensure main content takes remaining height */
        .flex-container {
            display: flex;
            flex: 1; /* Allows it to grow and fill available space */
            overflow: hidden; /* Prevents overflow issues with flex items */
        }

        /* Show thinking button within AI bubble */
        .show-thinking-button {
            background-color: #cbd5e1; /* slate-300 */
            color: #475569; /* slate-700 */
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.75rem; /* text-xs */
            cursor: pointer;
            margin-top: 8px;
            display: inline-block;
            transition: background-color 0.2s;
        }
        .ai-bubble.dark .show-thinking-button {
            background-color: #475569; /* slate-600 */
            color: #e2e8f0; /* slate-200 */
        }
        .show-thinking-button:hover {
            background-color: #94a3b8; /* slate-400 */
        }
        .ai-bubble.dark .show-thinking-button:hover {
            background-color: #64748b; /* slate-500 */
        }
        .thinking-details {
            margin-top: 8px;
            padding: 8px;
            background-color: #e2e8f0; /* slate-200 */
            border-radius: 8px;
            font-size: 0.875rem; /* text-sm */
            color: #475569; /* slate-700 */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            display: none; /* Hidden by default */
        }
        .ai-bubble.dark .thinking-details {
            background-color: #334155; /* slate-700 */
            color: #e2e8f0; /* slate-200 */
        }
    </style>
    <script>
        // Apply theme ASAP to avoid FOUC (Flash Of Unstyled Content)
        // This script runs before the DOM is fully loaded, setting the initial theme.
        // The theme is now permanently 'light' unless the user's system prefers dark mode.
        const initialTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        if (initialTheme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        // Remove theme preference from local storage if it exists, as it's no longer user-selectable
        localStorage.removeItem('theme');
    </script>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex flex-col h-screen transition-colors duration-300">

    <header class="bg-slate-800 dark:bg-slate-950 text-white p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-semibold">BetterGem AI Chat</h1>
            <button id="settings-button" class="p-2 rounded-md hover:bg-slate-700 dark:hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-slate-500 dark:focus:ring-slate-400">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 0 1 1.45.12l.773.774c.39.39.44 1.002.12 1.45l-.527.737c-.25.35-.272.806-.108 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.11v1.093c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.107 1.204l.527.738c.32.447.27.96-.12 1.45l-.774.773a1.125 1.125 0 0 1-1.449.12l-.738-.527c-.35-.25-.806-.272-1.203-.107-.397.165-.71.505-.78.93l-.15.894c-.09.542-.56.94-1.11.94h-1.094c-.55 0-1.019-.398-1.11-.94l-.149-.894c-.07-.424-.384-.764-.78-.93-.398-.164-.854-.142-1.204.108l-.738.527c-.447.32-.96.27-1.45-.12l-.773-.774a1.125 1.125 0 0 1-.12-1.45l.527-.737c.25-.35.272-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.11v-1.094c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.765-.383.93-.78.165-.398.143-.854-.108-1.204l-.526-.738a1.125 1.125 0 0 1 .12-1.45l.773-.773a1.125 1.125 0 0 1 1.45-.12l.737.527c.35.25.807.272 1.204.107.397-.165.71-.505.78-.93l.15-.893Z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                </svg>
            </button>
        </div>
    </header>

    <div class="flex-container flex-1 w-full max-w-7xl mx-auto py-4 px-2 sm:px-4">
        <aside class="w-full sm:w-64 bg-white dark:bg-slate-800 shadow rounded-lg p-4 mr-4 flex flex-col flex-shrink-0">
            <h2 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-4">Chats</h2>
            <button id="new-chat-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out mb-4">
                + New Chat
            </button>
            <div id="chat-list" class="flex-1 overflow-y-auto space-y-2">
                </div>
        </aside>

        <main id="chat-container" class="flex-1 flex flex-col">
            <div id="chat-messages" class="flex-1 space-y-4 overflow-y-auto p-4 bg-white dark:bg-slate-800 shadow rounded-lg mb-4">
                </div>

            <div class="bg-white dark:bg-slate-800 p-4 shadow rounded-lg">
                <div id="error-message" class="text-red-500 dark:text-red-400 text-sm mb-2 hidden"></div>
                <div id="api-key-prompt" class="text-amber-600 dark:text-amber-400 text-sm mb-2 hidden">
                    API Key not set. Please <button id="open-settings-from-prompt" class="underline font-semibold">set your API Key</button> in settings.
                </div>
                <div id="uploaded-files-preview" class="flex flex-wrap gap-2 mb-2 hidden"></div>

                <div id="action-buttons-container" class="flex flex-wrap items-center gap-2 mb-4">
                    <button id="upload-button" title="Upload File" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.75 3.75 0 0 1 18 19.5H6.75Z" />
                        </svg>
                    </button>
                    <input type="file" id="file-input" accept="image/*" class="hidden" multiple>

                    <button id="share-screen-button" title="Share Screen with AI" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 17.25v1.007a3 3 0 0 1-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0 1 15 18.257V17.25m6-12V15a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 15V5.25m18 0A2.25 2.25 0 0 0 18.75 3H5.25A2.25 2.25 0 0 0 3 5.25m18 0h.008v.008H21V5.25ZM9 12.75h.008v.008H9v-.008ZM12 12.75h.008v.008H12v-.008ZM15 12.75h.008v.008H15v-.008Z" />
                        </svg>
                    </button>

                    <button id="image-gen-toggle-button" title="Toggle Image Generation" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 1.5-1.5m1.5 1.5 1.5-1.5m-6.75 6.75h.75A2.25 2.25 0 0 0 4.5 18V9a2.25 2.25 0 0 1 2.25-2.25h10.5A2.25 2.25 0 0 1 19.5 9v9a2.25 2.25 0 0 0 2.25 2.25h.75m-14.25-10.5h.008v.008H7.5v-.008Zm6.75 0h.008v.008H14.25v-.008Z" />
                        </svg>
                    </button>

                    <button id="deep-research-toggle-button" title="Toggle Deep Research" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v6m3-3h-6"/>
                        </svg>
                    </button>

                    <button id="canvas-toggle-button" title="Toggle Canvas Mode" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12c0 1.01-.195 1.98-.546 2.917a1.05 1.05 0 0 0-.759-.759 1.05 1.05 0 0 0-1.992.45c-.407 1.132-1.49 2.064-2.809 2.576a1.05 1.05 0 0 0-1.086.112A4.5 4.5 0 0 1 12 18.75c-2.34 0-4.24-1.9-4.5-4.24a1.05 1.05 0 0 0-.112-1.086A5.25 5.25 0 0 1 7.25 12c0-1.01.195-1.98.546-2.917a1.05 1.05 0 0 0 .759-.759 1.05 1.05 0 0 0 1.992.45c.407 1.132 1.49 2.064 2.809 2.576a1.05 1.05 0 0 0 1.086.112A4.5 4.5 0 0 1 12 5.25c2.34 0 4.24 1.9 4.5 4.24a1.05 1.05 0 0 0 .112 1.086A5.25 5.25 0 0 1 18.75 12Z" />
                        </svg>
                    </button>

                    <button id="mic-button" title="Toggle Microphone" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg id="mic-icon-idle" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,151.6V240a8,8,0,0,1-16,0V215.6A80.07,80.07,0,0,1,48,128a8,8,0,0,1,16,0a64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.07,80.07,0,0,1,136,215.6Z"></path></svg>
                        <svg id="mic-icon-active" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256" class="hidden"><path d="M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,151.6V240a8,8,0,0,1-16,0V215.6A80.07,80.07,0,0,1,48,128a8,8,0,0,1,16,0a64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.07,80.07,0,0,1,136,215.6Z"></path></svg>
                    </button>
                    <button id="speaker-toggle-button" title="Toggle AI Voice" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg id="speaker-icon-on" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" class="hidden"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/><path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89l.706.706z"/><path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/></svg>
                        <svg id="speaker-icon-off" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zm7.137 2.096a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0z"/></svg>
                    </button>
                    <select id="voice-select-dropdown" title="Select AI Voice" class="p-3 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none hidden">
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <input type="text" id="message-input" class="flex-1 p-3 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Type or say your message...">
                    <button id="send-button" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-5 rounded-lg shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                </div>
                <div id="loading-indicator" class="mt-2 text-sm text-slate-500 dark:text-slate-400 hidden">
                    AI is thinking...
                </div>
            </div>
        </main>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-slate-700 dark:text-slate-200">Settings</h2>
                <span id="close-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            
            <div class="mb-4">
                <label for="api-key-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Gemini API Key:</label>
                <input type="password" id="api-key-input" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Enter your API Key">
                <button id="save-api-key-button" class="mt-3 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out">
                    Save Settings
                </button>
                 <p id="api-key-status" class="text-xs mt-2 text-slate-500 dark:text-slate-400"></p>
            </div>

            <div class="mb-4">
                <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-2">Feature Visibility</h3>
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <label for="toggle-upload-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Upload Button:</label>
                        <input type="checkbox" id="toggle-upload-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-share-screen-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Share Screen Button:</label>
                        <input type="checkbox" id="toggle-share-screen-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-image-gen-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Image Generation Button:</label>
                        <input type="checkbox" id="toggle-image-gen-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-deep-research-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Deep Research Button:</label>
                        <input type="checkbox" id="toggle-deep-research-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-canvas-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Canvas Mode Button:</label>
                        <input type="checkbox" id="toggle-canvas-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-mic-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Microphone Button:</label>
                        <input type="checkbox" id="toggle-mic-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-speaker-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show AI Voice Button:</label>
                        <input type="checkbox" id="toggle-speaker-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-thinking-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show "Show Thinking" Button:</label>
                        <input type="checkbox" id="toggle-thinking-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="customize-chat-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-slate-700 dark:text-slate-200">Customize Chat</h2>
                <span id="close-customize-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            
            <div class="mb-4">
                <label for="chat-name-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Chat Name:</label>
                <input type="text" id="chat-name-input" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Enter chat name">
            </div>

            <div class="mb-4">
                <label for="chat-profile-picture-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Profile Picture:</label>
                <div class="flex items-center space-x-4">
                    <input type="file" id="chat-profile-picture-input" accept="image/*" class="hidden">
                    <button id="select-profile-picture-button" class="bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-200 py-2 px-4 rounded-md hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors duration-150">
                        Select Image
                    </button>
                    <img id="chat-profile-picture-preview" class="w-16 h-16 rounded-full object-cover border border-slate-300 dark:border-slate-600" src="https://placehold.co/64x64/e2e8f0/64748b?text=AI" alt="Profile Preview">
                    <button id="remove-profile-picture-button" class="text-red-500 hover:text-red-700 text-sm hidden">Remove</button>
                </div>
            </div>

            <div class="mb-6">
                <label for="chat-prompt-info-textarea" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Prompt Information (System Message):</label>
                <textarea id="chat-prompt-info-textarea" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none h-32 resize-y" placeholder="Enter any specific instructions or context for the AI that will be sent at the start of each conversation."></textarea>
            </div>

            <div class="flex justify-end space-x-4">
                <button id="cancel-customize-chat-button" class="px-4 py-2 rounded-md bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-200 hover:bg-slate-400 dark:hover:bg-slate-700 transition-colors duration-150">
                    Cancel
                </button>
                <button id="save-customize-chat-button" class="px-4 py-2 rounded-md bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-150">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 id="confirmation-title" class="text-xl font-semibold text-slate-700 dark:text-slate-200">Confirm Action</h2>
                <span id="close-confirmation-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            <p id="confirmation-message" class="text-slate-700 dark:text-slate-300 mb-6">Are you sure you want to proceed?</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-confirmation-button" class="px-4 py-2 rounded-md bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-200 hover:bg-slate-400 dark:hover:bg-slate-700 transition-colors duration-150">
                    Cancel
                </button>
                <button id="confirm-action-button" class="px-4 py-2 rounded-md bg-red-500 text-white hover:bg-red-600 transition-colors duration-150">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <video id="screen-video" class="hidden" autoplay playsinline></video>
    <canvas id="screen-canvas" class="hidden"></canvas>

    <script>
        // DOM Elements
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const micIconIdle = document.getElementById('mic-icon-idle');
        const micIconActive = document.getElementById('mic-icon-active');
        const speakerToggleButton = document.getElementById('speaker-toggle-button');
        const speakerIconOn = document.getElementById('speaker-icon-on');
        const speakerIconOff = document.getElementById('speaker-icon-off');
        const voiceSelectDropdown = document.getElementById('voice-select-dropdown');
        const chatMessages = document.getElementById('chat-messages');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessageDiv = document.getElementById('error-message');
        
        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiKeyPrompt = document.getElementById('api-key-prompt');
        const openSettingsFromPromptButton = document.getElementById('open-settings-from-prompt');

        // New DOM Elements for chat list
        const newChatButton = document.getElementById('new-chat-button');
        const chatListContainer = document.getElementById('chat-list');

        // New DOM Elements for file upload and image generation
        const uploadButton = document.getElementById('upload-button');
        const fileInput = document.getElementById('file-input');
        const uploadedFilesPreview = document.getElementById('uploaded-files-preview');
        const imageGenToggleButton = document.getElementById('image-gen-toggle-button');
        const shareScreenButton = document.getElementById('share-screen-button'); // New screen share button
        const deepResearchToggleButton = document.getElementById('deep-research-toggle-button'); // New deep research button
        const canvasToggleButton = document.getElementById('canvas-toggle-button'); // New canvas button

        const screenVideo = document.getElementById('screen-video'); // Hidden video element
        const screenCanvas = document.getElementById('screen-canvas'); // Hidden canvas element

        // Custom Confirmation Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmActionButton = document.getElementById('confirm-action-button');
        const cancelConfirmationButton = document.getElementById('cancel-confirmation-button');
        const closeConfirmationModalButton = document.getElementById('close-confirmation-modal-button');

        // New DOM elements for feature visibility toggles in settings
        const toggleUploadButton = document.getElementById('toggle-upload-button');
        const toggleShareScreenButton = document.getElementById('toggle-share-screen-button');
        const toggleImageGenButton = document.getElementById('toggle-image-gen-button');
        const toggleDeepResearchButton = document.getElementById('toggle-deep-research-button');
        const toggleCanvasButton = document.getElementById('toggle-canvas-button');
        const toggleMicButton = document.getElementById('toggle-mic-button');
        const toggleSpeakerButton = document.getElementById('toggle-speaker-button');
        const toggleThinkingButton = document.getElementById('toggle-thinking-button');

        // DOM Elements for Customize Chat Modal
        const customizeChatModal = document.getElementById('customize-chat-modal');
        const closeCustomizeModalButton = document.getElementById('close-customize-modal-button');
        const chatNameInput = document.getElementById('chat-name-input');
        const chatProfilePictureInput = document.getElementById('chat-profile-picture-input');
        const selectProfilePictureButton = document.getElementById('select-profile-picture-button');
        const removeProfilePictureButton = document.getElementById('remove-profile-picture-button');
        const chatProfilePicturePreview = document.getElementById('chat-profile-picture-preview');
        const chatPromptInfoTextarea = document.getElementById('chat-prompt-info-textarea');
        const saveCustomizeChatButton = document.getElementById('save-customize-chat-button');
        const cancelCustomizeChatButton = document.getElementById('cancel-customize-chat-button');


        // State Variables
        // Stores all chat sessions: { chatId: { history: chatHistoryArray, name: 'Chat Name', profilePicture: 'data:image/...', promptInfo: '...' } }
        let chatSessions = {}; 
        let currentChatId = null; // ID of the currently active chat
        let chatHistory = []; // Reference to the chat history of the currentChatId
        let geminiApiKey = localStorage.getItem('geminiApiKey') || '';
        let aiVoiceEnabled = localStorage.getItem('aiVoiceEnabled') === 'true';
        let isImageGenerationEnabled = localStorage.getItem('isImageGenerationEnabled') === 'true'; // New state for image generation
        let isScreenSharingActive = false; // New state for screen sharing
        let isDeepResearchEnabled = localStorage.getItem('isDeepResearchEnabled') === 'true'; // New state for deep research
        let isCanvasEnabled = localStorage.getItem('isCanvasEnabled') === 'true'; // New state for canvas
        let screenStream = null; // Stores the MediaStream object
        let screenCaptureInterval = null; // Stores the interval ID for screen capture
        let latestScreenBase64 = null; // Stores the latest captured screen frame as Base64
        let selectedVoiceURI = localStorage.getItem('selectedVoiceURI') || '';
        let isRecording = false;
        let availableVoices = [];
        // Stores objects like { data: base64String, mimeType: 'image/jpeg' }.
        // `data` now stores the full data URL (e.g., "data:image/png;base64,...")
        let selectedFiles = []; 

        // Feature visibility states (enabled by default)
        // Initialize from localStorage, defaulting to true if not found
        let showUploadButton = localStorage.getItem('showUploadButton') !== 'false';
        let showShareScreenButton = localStorage.getItem('showShareScreenButton') !== 'false';
        let showImageGenButton = localStorage.getItem('showImageGenButton') !== 'false';
        let showDeepResearchButton = localStorage.getItem('showDeepResearchButton') !== 'false';
        let showCanvasButton = localStorage.getItem('showCanvasButton') !== 'false';
        let showMicButton = localStorage.getItem('showMicButton') !== 'false';
        let showSpeakerButton = localStorage.getItem('showSpeakerButton') !== 'false';
        let showThinkingButton = localStorage.getItem('showThinkingButton') !== 'false';


        // Speech Recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US'; // Corrected: was 'en-.interimResults = false;'
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                messageInput.value = speechResult;
                stopRecording();
                // Automatically send message after speech recognition if not empty
                if (messageInput.value.trim() !== '' || selectedFiles.length > 0 || isScreenSharingActive) {
                    sendMessage();
                }
            };
            recognition.onerror = (event) => {
                console.error("Speech recognition error", event.error);
                let errorMsg = `Mic error: ${event.error}`;
                if (event.error === 'no-speech') errorMsg = "No speech detected. Please try again.";
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') errorMsg = "Microphone access denied. Please enable it in your browser settings.";
                displayErrorMessage(errorMsg);
                stopRecording();
            };
            recognition.onend = () => { if (isRecording) stopRecording(); };
        } else {
            console.warn("Speech Recognition API not supported.");
            // Hide mic button if API not supported
            if(micButton) micButton.style.display = 'none';
        }

        // Speech Synthesis
        const synth = window.speechSynthesis;

        function populateVoiceList() {
            availableVoices = synth.getVoices();
            voiceSelectDropdown.innerHTML = ''; // Clear existing options
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Default Voice';
            voiceSelectDropdown.appendChild(defaultOption);

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.setAttribute('data-lang', voice.lang);
                option.setAttribute('data-name', voice.name);
                option.value = voice.voiceURI;
                if (voice.voiceURI === selectedVoiceURI) {
                    option.selected = true;
                }
                voiceSelectDropdown.appendChild(option);
            });
            voiceSelectDropdown.value = selectedVoiceURI; // re-apply selected URI
        }
        
        if (synth) {
            populateVoiceList();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoiceList;
            }
        } else {
            console.warn("Speech Synthesis API not supported.");
            // Hide speaker and voice dropdown if API not supported
            if(speakerToggleButton) speakerToggleButton.style.display = 'none';
            if(voiceSelectDropdown) voiceSelectDropdown.style.display = 'none';
        }

        /**
         * Speaks the given text using the selected AI voice.
         * @param {string} text - The text to speak.
         */
        function speakText(text) {
            if (!aiVoiceEnabled || !synth || !text) return;
            if (synth.speaking) {
                synth.cancel(); // Stop any ongoing speech
            }
            const utterThis = new SpeechSynthesisUtterance(text);
            utterThis.onerror = (event) => console.error('SpeechSynthesisUtterance.onerror', event);

            if (selectedVoiceURI) {
                const voice = availableVoices.find(v => v.voiceURI === selectedVoiceURI);
                if (voice) utterThis.voice = voice;
            }
            synth.speak(utterThis);
        }
        
        /**
         * Updates the UI for the speaker toggle button and voice select dropdown.
         */
        function updateSpeakerButtonUI() {
            if (aiVoiceEnabled) {
                speakerIconOn.classList.remove('hidden');
                speakerIconOff.classList.add('hidden');
                voiceSelectDropdown.classList.remove('hidden');
                speakerToggleButton.classList.add('speaker-active');
            } else {
                speakerIconOn.classList.add('hidden');
                speakerIconOff.classList.remove('hidden');
                voiceSelectDropdown.classList.add('hidden');
                speakerToggleButton.classList.remove('speaker-active');
            }
        }

        /**
         * Updates the UI for the image generation toggle button.
         */
        function updateImageGenButtonUI() {
            if (isImageGenerationEnabled) {
                imageGenToggleButton.classList.add('image-gen-active');
            } else {
                imageGenToggleButton.classList.remove('image-gen-active');
            }
        }

        /**
         * Updates the UI for the screen sharing button.
         */
        function updateScreenShareButtonUI() {
            if (isScreenSharingActive) {
                shareScreenButton.classList.add('screen-sharing-active');
            } else {
                shareScreenButton.classList.remove('screen-sharing-active');
            }
        }

        /**
         * Updates the UI for the deep research toggle button.
         */
        function updateDeepResearchButtonUI() {
            if (isDeepResearchEnabled) {
                deepResearchToggleButton.classList.add('deep-research-active');
            } else {
                deepResearchToggleButton.classList.remove('deep-research-active');
            }
        }

        /**
         * Updates the UI for the canvas toggle button.
         */
        function updateCanvasButtonUI() {
            if (isCanvasEnabled) {
                canvasToggleButton.classList.add('canvas-active');
            } else {
                canvasToggleButton.classList.remove('canvas-active');
            }
        }

        /**
         * Updates the visibility of all action buttons based on settings.
         */
        function updateButtonVisibilityUI() {
            // Apply display style based on feature visibility flags
            if (uploadButton) uploadButton.style.display = showUploadButton ? 'block' : 'none';
            if (shareScreenButton) shareScreenButton.style.display = showShareScreenButton ? 'block' : 'none';
            if (imageGenToggleButton) imageGenToggleButton.style.display = showImageGenButton ? 'block' : 'none';
            if (deepResearchToggleButton) deepResearchToggleButton.style.display = showDeepResearchButton ? 'block' : 'none';
            if (canvasToggleButton) canvasToggleButton.style.display = showCanvasButton ? 'block' : 'none';
            if (micButton) micButton.style.display = showMicButton ? 'block' : 'none';
            if (speakerToggleButton) speakerToggleButton.style.display = showSpeakerButton ? 'block' : 'none';

            // Also update the state of the checkboxes in the settings modal
            if (toggleUploadButton) toggleUploadButton.checked = showUploadButton;
            if (toggleShareScreenButton) toggleShareScreenButton.checked = showShareScreenButton;
            if (toggleImageGenButton) toggleImageGenButton.checked = showImageGenButton;
            if (toggleDeepResearchButton) toggleDeepResearchButton.checked = showDeepResearchButton;
            if (toggleCanvasButton) toggleCanvasButton.checked = showCanvasButton;
            if (toggleMicButton) toggleMicButton.checked = showMicButton;
            if (toggleSpeakerButton) toggleSpeakerButton.checked = showSpeakerButton;
            if (toggleThinkingButton) toggleThinkingButton.checked = showThinkingButton;


            // Ensure voice select dropdown visibility is linked to speaker button
            if (!showSpeakerButton) {
                voiceSelectDropdown.classList.add('hidden');
            } else {
                // Re-apply original logic for voice select dropdown based on aiVoiceEnabled
                updateSpeakerButtonUI();
            }
        }

        // --- Initialization ---
        /**
         * Initializes the application state and UI.
         */
        function initializeApp() {
            // Load feature visibility settings
            showUploadButton = localStorage.getItem('showUploadButton') !== 'false';
            showShareScreenButton = localStorage.getItem('showShareScreenButton') !== 'false';
            showImageGenButton = localStorage.getItem('showImageGenButton') !== 'false';
            showDeepResearchButton = localStorage.getItem('showDeepResearchButton') !== 'false';
            showCanvasButton = localStorage.getItem('showCanvasButton') !== 'false';
            showMicButton = localStorage.getItem('showMicButton') !== 'false';
            showSpeakerButton = localStorage.getItem('showSpeakerButton') !== 'false';
            showThinkingButton = localStorage.getItem('showThinkingButton') !== 'false';

            // Apply feature visibility
            updateButtonVisibilityUI();

            // AI Voice setup
            updateSpeakerButtonUI();
            // Image Generation setup
            updateImageGenButtonUI();
            // Screen sharing setup
            updateScreenShareButtonUI();
            // Deep Research setup
            updateDeepResearchButtonUI();
            // Canvas setup
            updateCanvasButtonUI();

            // Load chat sessions and set up initial chat
            loadChatSessionsFromStorage();
            updateApiKeyStatus(); // Update API key status in settings modal

            // Check API key and disable input if not set
            if (!geminiApiKey) {
                apiKeyPrompt.classList.remove('hidden');
                sendButton.disabled = true;
                if(micButton) micButton.disabled = true;
                if(uploadButton) uploadButton.disabled = true; // Disable upload if no API key
                if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen if no API key
                if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share if no API key
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research if no API key
                if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas if no API key
                // Add a system message if no API key is set and no chat history exists
                if (chatHistory.length === 0) {
                    addMessageToChat("Welcome! Please set your Gemini API Key in the settings to start chatting.", 'system');
                }
            } else {
                apiKeyPrompt.classList.add('hidden');
                sendButton.disabled = false;
                if(micButton) micButton.disabled = false;
                if(uploadButton) uploadButton.disabled = false; // Enable upload if API key
                if(imageGenToggleButton) imageGenToggleButton.disabled = false; // Enable image gen if API key
                if(shareScreenButton) shareScreenButton.disabled = false; // Enable screen share if API key
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = false; // Enable deep research if API key
                if(canvasToggleButton) canvasToggleButton.disabled = false; // Enable canvas if API key
                // Only add welcome message if the current chat is truly empty
                if (chatHistory.length === 0) {
                    addMessageToChat("Welcome! How can I help you today?", 'system');
                }
            }
            // Display history for the current chat
            displayCurrentChatHistory();
        }

        /**
         * Toggles the visibility of the thinking details for a given message.
         * @param {HTMLElement} buttonElement - The "Show Thinking" button that was clicked.
         */
        function toggleThinkingDetails(buttonElement) {
            const thinkingDetails = buttonElement.nextElementSibling; // Get the next sibling, which should be the thinking details div
            if (thinkingDetails && thinkingDetails.classList.contains('thinking-details')) {
                if (thinkingDetails.style.display === 'block') {
                    thinkingDetails.style.display = 'none';
                    buttonElement.textContent = 'Show Thinking';
                } else {
                    thinkingDetails.style.display = 'block';
                    buttonElement.textContent = 'Hide Thinking';
                }
            }
        }

        // --- Chat Functions ---
        /**
         * Adds a message bubble to the chat display.
         * @param {string} message - The text content of the message.
         * @param {string} sender - The sender of the message ('user', 'ai', or 'system').
         * @param {boolean} [isLoading=false] - True if this is a temporary loading message.
         * @param {Array<Object>} [files=[]] - Array of file objects ({data: base64DataUrl, mimeType: string}) for display.
         * @param {number} [messageIndex=-1] - The index of the message in chatHistory, for deletion.
         */
        function addMessageToChat(message, sender, isLoading = false, files = [], messageIndex = -1) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-bubble');
            
            if (sender === 'user') {
                // Apply Tailwind classes for user bubble
                messageElement.classList.add('bg-blue-500', 'text-white', 'dark:bg-blue-700', 'dark:text-white');
                messageElement.classList.add('user-bubble'); // Keep for specific border-radius
            } else if (sender === 'ai') {
                // Apply Tailwind classes for AI bubble
                messageElement.classList.add('bg-gray-200', 'dark:bg-slate-700', 'text-slate-800', 'dark:text-slate-200');
                messageElement.classList.add('ai-bubble'); // Keep for specific border-radius
            } else { // system messages
                messageElement.classList.add('system-bubble');
            }
            
            // Add message text
            const textContent = document.createElement('p');
            textContent.textContent = message;
            messageElement.appendChild(textContent);

            // Add image previews if files are present
            if (files && files.length > 0) {
                files.forEach(file => {
                    if (file.mimeType.startsWith('image/')) {
                        const img = document.createElement('img');
                        // Use the full data URL directly
                        img.src = file.data; 
                        img.alt = 'Uploaded image';
                        img.classList.add('mt-2', 'rounded-md', 'max-w-full', 'h-auto', 'max-h-48', 'object-contain');
                        messageElement.appendChild(img);
                    }
                    // Could add handling for other file types here if needed
                });
            }

            // Add "Show Thinking" button for AI messages (if not a loading message)
            if (sender === 'ai' && !isLoading && showThinkingButton) { // Check showThinkingButton state
                const showThinkingButtonElement = document.createElement('button');
                showThinkingButtonElement.classList.add('show-thinking-button');
                showThinkingButtonElement.textContent = 'Show Thinking';
                showThinkingButtonElement.addEventListener('click', (event) => {
                    toggleThinkingDetails(event.target);
                });
                messageElement.appendChild(showThinkingButtonElement);

                const thinkingDetailsDiv = document.createElement('div');
                thinkingDetailsDiv.classList.add('thinking-details');
                thinkingDetailsDiv.textContent = 'Detailed thinking process not available via current API.'; // Placeholder message
                messageElement.appendChild(thinkingDetailsDiv);
            }

            // Add delete button for messages (not for system messages or loading bubbles)
            if (sender !== 'system' && !isLoading) {
                const deleteMsgButton = document.createElement('button');
                deleteMsgButton.classList.add('delete-message-button');
                deleteMsgButton.textContent = 'X';
                deleteMsgButton.title = 'Delete message';
                deleteMsgButton.addEventListener('click', () => showConfirmationModal('Delete Message', 'Are you sure you want to delete this message?', () => deleteMessageConfirmed(messageIndex)));
                messageElement.appendChild(deleteMsgButton);
            }


            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (isLoading) messageElement.setAttribute('id', 'loading-bubble');
        }

        /**
         * Clears any displayed error messages.
         */
        function clearErrorMessage() {
            errorMessageDiv.textContent = '';
            errorMessageDiv.classList.add('hidden');
        }

        /**
         * Displays an error message temporarily.
         * @param {string} message - The error message to display.
         */
        function displayErrorMessage(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            setTimeout(clearErrorMessage, 6000); // Hide after 6 seconds
        }

        /**
         * Sends the user's message to the Gemini API and handles the response.
         */
        async function sendMessage() {
            const messageText = messageInput.value.trim();
            // Only send if there's text, selected files, or screen sharing is active
            if (!messageText && selectedFiles.length === 0 && !isScreenSharingActive) return;

            if (!geminiApiKey) {
                displayErrorMessage("API Key is not set. Please set it in settings.");
                apiKeyPrompt.classList.remove('hidden');
                return;
            }
            clearErrorMessage();

            // Construct parts for the API payload for user message
            const userMessageParts = [];
            if (messageText) {
                userMessageParts.push({ text: messageText });
            }
            selectedFiles.forEach(file => {
                // For the API, we need the base64 string without the "data:mimeType;base64," prefix
                const base64Only = file.data.split(',')[1];
                userMessageParts.push({ inlineData: { mimeType: file.mimeType, data: base64Only } });
            });

            // Add latest screen capture if active
            if (isScreenSharingActive && latestScreenBase64) {
                userMessageParts.push({ inlineData: { mimeType: "image/jpeg", data: latestScreenBase64.split(',')[1] } });
                // For display in the user bubble, we need the full data URL
                selectedFiles.push({ data: latestScreenBase64, mimeType: "image/jpeg" });
                latestScreenBase64 = null; // Clear after sending
            }

            // Get prompt info from the current chat session
            const currentChat = chatSessions[currentChatId];
            const promptInfo = currentChat ? currentChat.promptInfo : '';

            // If prompt info exists, prepend it to the history (as a system message, not chat bot message)
            let chatHistoryForApi = [...chatHistory];
            if (promptInfo) {
                chatHistoryForApi.unshift({ role: "system", parts: [{ text: promptInfo }] });
            }

            // Add user message to current chat history and display
            addMessageToChat(messageText, 'user', false, selectedFiles, chatHistory.length); // Pass current index
            chatHistory.push({ role: "user", parts: userMessageParts }); // Save full parts to history
            saveChatSessionsToStorage(); // Save updated history

            messageInput.value = '';
            selectedFiles = []; // Clear selected files after sending
            uploadedFilesPreview.innerHTML = ''; // Clear preview UI
            uploadedFilesPreview.classList.add('hidden'); // Hide preview container

            sendButton.disabled = true;
            if(micButton) micButton.disabled = true;
            if(speakerToggleButton) speakerToggleButton.disabled = true;
            if(uploadButton) uploadButton.disabled = true; // Disable upload button during sending
            if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen button during sending
            if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share button during sending
            if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research if no API key
            if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas if no API key


            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "AI is thinking...";
            addMessageToChat("Thinking...", 'ai', true); // Add a temporary loading message

            try {
                // 1. Call Gemini for text response
                const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
                const textPayload = { contents: chatHistoryForApi }; // Use chatHistoryForApi

                const textResponse = await fetch(textApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(textPayload)
                });

                if (!textResponse.ok) {
                    const errorData = await textResponse.json();
                    let detailedError = `Text AI Error: ${textResponse.status}`;
                    if (errorData && errorData.error && errorData.error.message) detailedError += ` - ${errorData.error.message}`;
                    throw new Error(detailedError);
                }

                const textResult = await textResponse.json();
                let aiResponseText = "Sorry, I couldn't get a text response.";
                if (textResult.candidates && textResult.candidates[0]?.content?.parts?.[0]?.text) {
                    aiResponseText = textResult.candidates[0].content.parts[0].text;
                } else if (textResult.promptFeedback?.blockReason) {
                     aiResponseText = `Text response blocked: ${textResult.promptFeedback.blockReason}.`;
                }

                // Append messages about unavailable features if toggled
                if (isDeepResearchEnabled) {
                    aiResponseText += "\n\n(Note: Deep Research is not available via the current API.)";
                }
                if (isCanvasEnabled) {
                    aiResponseText += "\n\n(Note: Canvas output is not available via the current API.)";
                }

                // 2. If image generation is enabled, call Imagen for image
                let generatedImageForDisplay = null;
                let generatedImageForHistory = null;

                if (isImageGenerationEnabled && messageText) { // Only generate image if there's a text prompt
                    loadingIndicator.textContent = "AI is generating image..."; // Update loading message
                    try {
                        const imagePayload = { instances: { prompt: messageText }, parameters: { "sampleCount": 1} };
                        const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${geminiApiKey}`;

                        const imageResponse = await fetch(imageApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(imagePayload)
                        });

                        if (!imageResponse.ok) {
                            const errorData = await imageResponse.json();
                            throw new Error(`Image API Error: ${imageResponse.status} - ${errorData.error?.message || 'Unknown error'}`);
                        }

                        const imageResult = await imageResponse.json();
                        if (imageResult.predictions && imageResult.predictions.length > 0 && imageResult.predictions[0].bytesBase64Encoded) {
                            const imageUrl = `data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`;
                            generatedImageForDisplay = { data: imageUrl, mimeType: "image/png" };
                            generatedImageForHistory = { inlineData: { mimeType: "image/png", data: imageResult.predictions[0].bytesBase64Encoded } };
                        } else {
                            console.warn("No image generated or unexpected image response structure.");
                        }
                    } catch (imageError) {
                        console.error("Error generating image:", imageError);
                        displayErrorMessage(`Image generation failed: ${imageError.message}`);
                    }
                }

                // Remove the "Thinking..." bubble
                const loadingBubble = document.getElementById('loading-bubble');
                if (loadingBubble) {
                    loadingBubble.remove();
                }

                // Construct AI response parts for history and display
                const aiResponsePartsForHistory = [{ text: aiResponseText }];
                const aiResponseFilesForDisplay = [];
                if (generatedImageForHistory) {
                    aiResponsePartsForHistory.push(generatedImageForHistory);
                    aiResponseFilesForDisplay.push(generatedImageForDisplay);
                }

                // Add the AI's actual response to chat display
                addMessageToChat(aiResponseText, 'ai', false, aiResponseFilesForDisplay, chatHistory.length);
                chatHistory.push({ role: "model", parts: aiResponsePartsForHistory }); // Save all parts to history
                saveChatSessionsToStorage();
                speakText(aiResponseText);

            } catch (error) {
                const errorMessageText = `Error: ${error.message || "Could not connect to AI."}`;
                // Remove the "Thinking..." bubble before displaying error in its place
                const loadingBubble = document.getElementById('loading-bubble');
                if (loadingBubble) {
                    loadingBubble.remove();
                }
                addMessageToChat(errorMessageText, 'ai', false, [], chatHistory.length); // Display error in chat bubble
                chatHistory.push({ role: "model", parts: [{ text: errorMessageText }] });
                displayErrorMessage(errorMessageText); // Display error in dedicated error div
            } finally {
                sendButton.disabled = false;
                if(micButton) micButton.disabled = geminiApiKey ? false : true;
                if(speakerToggleButton) speakerToggleButton.disabled = false;
                if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload button
                if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen button
                if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share button
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research button
                if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas button
                loadingIndicator.classList.add('hidden');
                loadingIndicator.textContent = "AI is thinking..."; // Reset loading text
                messageInput.focus();
                renderChatList(); // Re-render chat list to update names if first message was sent
            }
        }

        /**
         * Deletes a specific message from the current chat history.
         * This function is called after confirmation from the custom modal.
         * @param {number} indexToDelete - The index of the message to delete.
         */
        function deleteMessageConfirmed(indexToDelete) {
            if (indexToDelete >= 0 && indexToDelete < chatHistory.length) {
                chatHistory.splice(indexToDelete, 1);
                saveChatSessionsToStorage();
                displayCurrentChatHistory(); // Re-render chat to reflect deletion
            }
            hideConfirmationModal(); // Hide the modal after action
        }

        // --- Custom Confirmation Modal Functions ---
        let confirmCallback = null;

        /**
         * Displays the custom confirmation modal.
         * @param {string} title - The title for the confirmation modal.
         * @param {string} message - The message to display in the confirmation modal.
         * @param {Function} onConfirm - The callback function to execute if the user confirms.
         */
        function showConfirmationModal(title, message, onConfirm) {
            confirmationTitle.textContent = title;
            confirmationMessage.textContent = message;
            confirmCallback = onConfirm; // Store the callback
            confirmationModal.style.display = 'flex';
        }

        /**
         * Hides the custom confirmation modal.
         */
        function hideConfirmationModal() {
            confirmationModal.style.display = 'none';
            confirmCallback = null; // Clear the callback
        }

        // Event listeners for the custom confirmation modal
        confirmActionButton.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback(); // Execute the stored callback
            }
        });

        cancelConfirmationButton.addEventListener('click', hideConfirmationModal);
        closeConfirmationModalButton.addEventListener('click', hideConfirmationModal);


        // --- Speech Recognition Control ---
        /**
         * Starts the speech recognition process.
         */
        function startRecording() {
            if (!recognition || !micButton) return;
            if (isRecording) return;

            try {
                isRecording = true;
                recognition.start();
                micIconIdle.classList.add('hidden');
                micIconActive.classList.remove('hidden');
                micButton.classList.add('mic-active');
                sendButton.disabled = true;
                if(uploadButton) uploadButton.disabled = true; // Disable upload during recording
                if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen during recording
                if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share during recording
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research during recording
                if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas during recording
                messageInput.placeholder = "Listening...";
            } catch (e) {
                isRecording = false;
                if (e.name === 'InvalidStateError') displayErrorMessage("Mic busy or already started.");
                else displayErrorMessage("Could not start microphone.");
                micIconIdle.classList.remove('hidden');
                micIconActive.classList.add('hidden');
                micButton.classList.remove('mic-active');
                sendButton.disabled = geminiApiKey ? false : true;
                if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload
                if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen
                if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research
                if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas
                messageInput.placeholder = "Type or say your message...";
            }
        }

        /**
         * Stops the speech recognition process.
         */
        function stopRecording() {
            if (!recognition || !micButton) return;
            if (!isRecording) return;

            recognition.stop();
            isRecording = false;
            micIconIdle.classList.remove('hidden');
            micIconActive.classList.add('hidden');
            micButton.classList.remove('mic-active');
            sendButton.disabled = geminiApiKey ? false : true;
            if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload
            if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen
            if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share
            if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research
            if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas
            messageInput.placeholder = "Type or say your message...";
        }
        
        if(micButton) {
            micButton.addEventListener('click', () => {
                if (isRecording) stopRecording();
                else startRecording();
            });
        }


        // --- Settings Modal Functions ---
        /**
         * Opens the settings modal.
         */
        function openSettingsModal() {
            apiKeyInput.value = geminiApiKey;
            // Set checkbox states when opening modal
            if (toggleUploadButton) toggleUploadButton.checked = showUploadButton;
            if (toggleShareScreenButton) toggleShareScreenButton.checked = showShareScreenButton;
            if (toggleImageGenButton) toggleImageGenButton.checked = showImageGenButton;
            if (toggleDeepResearchButton) toggleDeepResearchButton.checked = showDeepResearchButton;
            if (toggleCanvasButton) toggleCanvasButton.checked = showCanvasButton;
            if (toggleMicButton) toggleMicButton.checked = showMicButton;
            if (toggleSpeakerButton) toggleSpeakerButton.checked = showSpeakerButton;
            if (toggleThinkingButton) toggleThinkingButton.checked = showThinkingButton;

            settingsModal.style.display = 'flex';
        }

        /**
         * Closes the settings modal.
         */
        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        /**
         * Saves the entered API key and feature visibility settings to local storage.
         */
        function saveSettings() {
            const newApiKey = apiKeyInput.value.trim();
            if (newApiKey) {
                geminiApiKey = newApiKey;
                localStorage.setItem('geminiApiKey', geminiApiKey);
                updateApiKeyStatus();
                apiKeyPrompt.classList.add('hidden');
                sendButton.disabled = false;
                if(micButton) micButton.disabled = false;
                if(uploadButton) uploadButton.disabled = false; // Enable upload button
                if(imageGenToggleButton) imageGenToggleButton.disabled = false; // Enable image gen button
                if(shareScreenButton) shareScreenButton.disabled = false; // Enable screen share button
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = false; // Enable deep research
                if(canvasToggleButton) canvasToggleButton.disabled = false; // Enable canvas
                clearErrorMessage();
                addMessageToChat("API Key saved. You can now chat.", 'system');
            } else {
                apiKeyStatus.textContent = 'API Key cannot be empty.';
                apiKeyStatus.classList.remove('text-slate-500', 'dark:text-slate-400', 'text-green-600', 'dark:text-green-500');
                apiKeyStatus.classList.add('text-red-500', 'dark:text-red-400');
            }

            // Save feature visibility settings and update UI immediately
            showUploadButton = toggleUploadButton.checked;
            localStorage.setItem('showUploadButton', showUploadButton);

            showShareScreenButton = toggleShareScreenButton.checked;
            localStorage.setItem('showShareScreenButton', showShareScreenButton);

            showImageGenButton = toggleImageGenButton.checked;
            localStorage.setItem('showImageGenButton', showImageGenButton);

            showDeepResearchButton = toggleDeepResearchButton.checked;
            localStorage.setItem('isDeepResearchEnabled', isDeepResearchEnabled);

            showCanvasButton = toggleCanvasButton.checked;
            localStorage.setItem('showCanvasButton', showCanvasButton);

            showMicButton = toggleMicButton.checked;
            localStorage.setItem('showMicButton', showMicButton);

            showSpeakerButton = toggleSpeakerButton.checked;
            localStorage.setItem('showSpeakerButton', showSpeakerButton);

            showThinkingButton = toggleThinkingButton.checked;
            localStorage.setItem('showThinkingButton', showThinkingButton);


            updateButtonVisibilityUI(); // Apply visibility changes immediately
            displayCurrentChatHistory(); // Re-render chat messages to apply "Show Thinking" button visibility
            closeSettingsModal();
        }
        
        /**
         * Updates the API key status message in the settings modal.
         */
        function updateApiKeyStatus() {
            if (geminiApiKey) {
                apiKeyStatus.textContent = 'API Key is set.';
                apiKeyStatus.classList.remove('text-red-500', 'dark:text-red-400');
                apiKeyStatus.classList.add('text-green-600', 'dark:text-green-500');
            } else {
                apiKeyStatus.textContent = 'API Key is not set.';
                apiKeyStatus.classList.remove('text-green-600', 'dark:text-green-500');
                apiKeyStatus.classList.add('text-red-500', 'dark:text-red-400');
            }
        }

        // --- Chat Session Management ---

        /**
         * Generates a unique ID for a new chat session.
         * @returns {string} A unique ID.
         */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        /**
         * Saves all chat sessions to local storage.
         */
        function saveChatSessionsToStorage() {
            try {
                localStorage.setItem('geminiChatSessions', JSON.stringify(chatSessions));
                localStorage.setItem('currentChatId', currentChatId); // Save current chat ID
            } catch (e) {
                console.warn("Could not save chat sessions:", e);
            }
        }

        /**
         * Loads all chat sessions from local storage.
         */
        function loadChatSessionsFromStorage() {
            const storedSessions = localStorage.getItem('geminiChatSessions');
            if (storedSessions) {
                try {
                    const parsedSessions = JSON.parse(storedSessions);
                    // Ensure loaded data matches the new structure, adapt if old structure is found
                    if (typeof parsedSessions === 'object' && parsedSessions !== null) {
                        for (const id in parsedSessions) {
                            // If an old entry (just an array) is found, convert it
                            if (Array.isArray(parsedSessions[id])) {
                                chatSessions[id] = { history: parsedSessions[id], name: `Chat ${Object.keys(chatSessions).length + 1}` };
                            } else {
                                chatSessions[id] = parsedSessions[id];
                                // Ensure name, profilePicture, promptInfo exist for existing chats
                                if (!chatSessions[id].name) {
                                    chatSessions[id].name = `Chat ${Object.keys(chatSessions).length + 1}`;
                                }
                                if (!chatSessions[id].profilePicture) {
                                    chatSessions[id].profilePicture = ''; // Default to empty
                                }
                                if (!chatSessions[id].promptInfo) {
                                    chatSessions[id].promptInfo = ''; // Default to empty
                                }
                            }
                        }
                    } else {
                        localStorage.removeItem('geminiChatSessions');
                        chatSessions = {};
                    }
                } catch (e) {
                    localStorage.removeItem('geminiChatSessions');
                    chatSessions = {};
                }
            }

            // If no sessions exist or parsing failed, create a default one
            if (Object.keys(chatSessions).length === 0) {
                startNewChat(false, true); // Start a new chat AND show customize modal
            } else {
                // Set currentChatId to the last active one or the first available chat
                currentChatId = localStorage.getItem('currentChatId') || Object.keys(chatSessions)[0];
                // Fallback if the stored currentChatId no longer exists
                if (!chatSessions[currentChatId]) {
                    currentChatId = Object.keys(chatSessions)[0];
                }
                chatHistory = chatSessions[currentChatId].history || []; // Access history property
            }
            renderChatList();
        }

        /**
         * Displays the messages of the current chat history in the chat messages area.
         */
        function displayCurrentChatHistory() {
            chatMessages.innerHTML = ''; // Clear existing messages
            chatHistory.forEach((item, index) => {
                // Reconstruct message and files from parts
                let messageText = '';
                const filesToDisplay = [];
                item.parts.forEach(part => {
                    if (part.text) {
                        messageText += part.text;
                    } else if (part.inlineData) {
                        // Crucial fix: re-add the data URI prefix for display
                        filesToDisplay.push({
                            data: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
                            mimeType: part.inlineData.mimeType
                        });
                    }
                });
                addMessageToChat(messageText, item.role === 'user' ? 'user' : 'ai', false, filesToDisplay, index); // Pass index
            });
            chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom
        }


        /**
         * Renders (or re-renders) the list of chat sessions in the sidebar.
         */
        function renderChatList() {
            chatListContainer.innerHTML = ''; // Clear existing list items
            const chatIds = Object.keys(chatSessions).sort((a, b) => {
                // Sort by creation time (assuming IDs are timestamp-based)
                return parseInt(a.substring(0, a.indexOf('.')), 36) - parseInt(b.substring(0, b.indexOf('.')), 36);
            });

            if (chatIds.length === 0) {
                // If no chats, ensure a new one is created
                startNewChat(false, true); // Create and immediately show customize modal
                return;
            }

            chatIds.forEach((chatId, index) => {
                const chatItem = document.createElement('div');
                chatItem.classList.add(
                    'chat-list-item',
                    'flex', 'items-center', 'justify-between', 'p-3', 'rounded-lg', 'cursor-pointer',
                    'hover:bg-slate-200', 'dark:hover:bg-slate-700', 'transition-colors', 'duration-150',
                    'text-slate-700', 'dark:text-slate-200'
                );
                if (chatId === currentChatId) {
                    chatItem.classList.add('active');
                }
                chatItem.dataset.chatId = chatId;

                // Determine chat name: stored name, first user message, first AI response, or generic
                let chatName = chatSessions[chatId].name;
                const history = chatSessions[chatId].history;

                if (!chatName || chatName.startsWith('Chat ')) { // If no custom name or generic name
                    if (history && history.length > 0) {
                        const firstUserMessagePart = history.find(msg => msg.role === 'user')?.parts.find(part => part.text);
                        const firstAiResponsePart = history.find(msg => msg.role === 'model')?.parts.find(part => part.text);
                        if (firstUserMessagePart) {
                            chatName = firstUserMessagePart.text.substring(0, 30) + (firstUserMessagePart.text.length > 30 ? '...' : '');
                        } else if (firstAiResponsePart) {
                            chatName = firstAiResponsePart.text.substring(0, 30) + (firstAiResponsePart.text.length > 30 ? '...' : '');
                        } else {
                            chatName = `Chat ${index + 1}`;
                        }
                    } else {
                        chatName = `Chat ${index + 1}`;
                    }
                    chatSessions[chatId].name = chatName; // Update name in session data
                }
                
                const chatNameSpan = document.createElement('span');
                chatNameSpan.textContent = chatName;
                chatNameSpan.classList.add('flex-1', 'truncate'); // Ensure text truncates if too long

                // Add profile picture to chat list item
                const chatProfilePic = document.createElement('img');
                chatProfilePic.classList.add('w-8', 'h-8', 'rounded-full', 'object-cover', 'mr-2', 'flex-shrink-0');
                chatProfilePic.src = chatSessions[chatId].profilePicture || 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Default or stored
                chatProfilePic.alt = 'Chat Profile';


                const buttonsContainer = document.createElement('div');
                buttonsContainer.classList.add('flex', 'items-center', 'space-x-1', 'ml-2');

                // Customize button (replaces rename)
                const customizeButton = document.createElement('button');
                customizeButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 text-slate-400 hover:text-blue-500 dark:hover:text-blue-400">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14.25v4.5a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 18V7.5a2.25 2.25 0 0 1 2.25-2.25h4.5" />
                    </svg>
                `;
                customizeButton.classList.add('w-6', 'h-6', 'p-1', 'rounded-full', 'hover:bg-slate-300', 'dark:hover:bg-slate-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'flex', 'items-center', 'justify-center');
                customizeButton.title = "Customize Chat";
                customizeButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent switching chat when customizing
                    openCustomizeChatModal(chatId);
                });
                buttonsContainer.appendChild(customizeButton);


                const deleteButton = document.createElement('button');
                // Simple 'X' icon for delete
                deleteButton.innerHTML = `
                    <span class="text-base leading-none text-slate-400 hover:text-red-500 dark:hover:text-red-400">&times;</span>
                `;
                // Adjusted w-6 h-6 and text-base for better visual alignment
                deleteButton.classList.add('w-6', 'h-6', 'p-1', 'rounded-full', 'hover:bg-slate-300', 'dark:hover:bg-slate-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-red-500', 'flex', 'items-center', 'justify-center');
                deleteButton.title = "Delete Chat";
                deleteButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent switching chat when deleting
                    showConfirmationModal('Delete Chat', 'Are you sure you want to delete this chat?', () => deleteChatConfirmed(chatId));
                });
                buttonsContainer.appendChild(deleteButton);

                chatItem.appendChild(chatProfilePic); // Add profile picture to the left
                chatItem.appendChild(chatNameSpan);
                chatItem.appendChild(buttonsContainer); // Append the container with both buttons
                chatItem.addEventListener('click', () => switchChat(chatId));
                chatListContainer.appendChild(chatItem);
            });
        }

        /**
         * Starts a new chat session.
         * @param {boolean} [savePrevious=true] - Whether to save the current chat before starting a new one.
         * @param {boolean} [openCustomizeModal=false] - Whether to open the customize modal immediately after creating.
         */
        function startNewChat(savePrevious = true, openCustomizeModalAfterCreation = false) {
            if (savePrevious && currentChatId && chatSessions[currentChatId]) {
                // Ensure the current chat's history is saved before switching
                chatSessions[currentChatId].history = chatHistory; // Save history
            }

            const newId = generateUniqueId();
            const newChatName = `Chat ${Object.keys(chatSessions).length + 1}`;
            chatSessions[newId] = { history: [], name: newChatName, profilePicture: '', promptInfo: '' }; // Initialize with empty history, default name, no picture, no prompt
            currentChatId = newId;
            chatHistory = chatSessions[currentChatId].history; // Update reference to new chat's history

            saveChatSessionsToStorage();
            displayCurrentChatHistory(); // Clear and display empty chat
            addMessageToChat("Welcome! How can I help you today?", 'system');
            messageInput.value = ''; // Clear input field
            messageInput.focus();
            selectedFiles = []; // Clear any pending selected files
            uploadedFilesPreview.innerHTML = ''; // Clear preview UI
            uploadedFilesPreview.classList.add('hidden'); // Hide preview container
            renderChatList(); // Re-render list to show new chat and highlight it

            if (openCustomizeModalAfterCreation) {
                openCustomizeChatModal(newId);
            }
        }

        /**
         * Switches the current chat session to the specified chatId.
         * @param {string} chatId - The ID of the chat session to switch to.
         */
        function switchChat(chatId) {
            if (chatId === currentChatId) return; // Already on this chat

            // Save the current chat's history before switching
            if (currentChatId && chatSessions[currentChatId]) {
                chatSessions[currentChatId].history = chatHistory; // Save history
            }

            currentChatId = chatId;
            chatHistory = chatSessions[currentChatId].history; // Update reference to new chat's history
            saveChatSessionsToStorage(); // Save updated currentChatId

            displayCurrentChatHistory(); // Display messages of the new chat
            renderChatList(); // Update active state in the list
            messageInput.focus();
            selectedFiles = []; // Clear any pending selected files
            uploadedFilesPreview.innerHTML = ''; // Clear preview UI
            uploadedFilesPreview.classList.add('hidden'); // Hide preview container
        }

        /**
         * Deletes a chat session by its ID.
         * This function is called after confirmation from the custom modal.
         * @param {string} chatIdToDelete - The ID of the chat session to delete.
         */
        function deleteChatConfirmed(chatIdToDelete) {
            delete chatSessions[chatIdToDelete];
            saveChatSessionsToStorage();

            if (chatIdToDelete === currentChatId) {
                // If the deleted chat was the current one, switch to another or create new
                const remainingChatIds = Object.keys(chatSessions);
                if (remainingChatIds.length > 0) {
                    switchChat(remainingChatIds[0]); // Switch to the first remaining chat
                } else {
                    startNewChat(false, true); // No chats left, start a brand new one and open customize modal
                }
            }
            renderChatList(); // Re-render the list after deletion
            hideConfirmationModal(); // Hide the modal after action
        }

        // --- File Upload Functions ---
        /**
         * Handles the selection of files from the file input.
         * @param {Event} event - The change event from the file input.
         */
        function handleFileSelection(event) {
            selectedFiles = []; // Clear previous selections
            uploadedFilesPreview.innerHTML = ''; // Clear previous previews
            uploadedFilesPreview.classList.add('hidden');

            const files = event.target.files;
            if (files.length === 0) return;

            // Limit to 1 image for simplicity with Gemini API, or handle multiple images if needed
            if (files.length > 1) {
                displayErrorMessage("Only one image can be uploaded at a time.");
                fileInput.value = ''; // Clear the input
                return;
            }

            const file = files[0];
            if (!file.type.startsWith('image/')) {
                displayErrorMessage("Only image files are supported.");
                fileInput.value = ''; // Clear the input
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                // Store the full data URL for display purposes
                const fullDataUrl = e.target.result; 
                selectedFiles.push({
                    data: fullDataUrl, // Store full data URL
                    mimeType: file.type
                });
                displaySelectedFiles();
            };
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                displayErrorMessage("Failed to read file.");
            };
            reader.readAsDataURL(file);
        }

        /**
         * Displays the selected files as previews in the UI.
         */
        function displaySelectedFiles() {
            uploadedFilesPreview.innerHTML = '';
            if (selectedFiles.length > 0) {
                uploadedFilesPreview.classList.remove('hidden');
                selectedFiles.forEach((file, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.classList.add('relative', 'w-24', 'h-24', 'rounded-md', 'overflow-hidden', 'shadow-md');

                    const img = document.createElement('img');
                    img.src = file.data; // Use the full data URL
                    img.alt = `Preview ${index}`;
                    img.classList.add('w-full', 'h-full', 'object-cover');

                    const removeButton = document.createElement('button');
                    removeButton.classList.add(
                        'absolute', 'top-1', 'right-1', 'bg-red-500', 'text-white', 'rounded-full',
                        'w-6', 'h-6', 'flex', 'items-center', 'justify-center', 'text-xs', 'font-bold',
                        'hover:bg-red-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-red-400'
                    );
                    removeButton.textContent = 'X';
                    removeButton.title = 'Remove image';
                    removeButton.addEventListener('click', () => removeFile(index));

                    previewItem.appendChild(img);
                    previewItem.appendChild(removeButton);
                    uploadedFilesPreview.appendChild(previewItem);
                });
            } else {
                uploadedFilesPreview.classList.add('hidden');
            }
        }

        /**
         * Removes a file from the selectedFiles array and updates the preview.
         * @param {number} index - The index of the file to remove.
         */
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            fileInput.value = ''; // Clear the file input so same file can be re-selected
            displaySelectedFiles();
        }

        // --- Screen Sharing Functions ---
        /**
         * Starts screen sharing and begins capturing frames.
         */
        async function startScreenSharing() {
            if (isScreenSharingActive) return;

            try {
                // Request screen sharing with video only (audio handled by mic button)
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                
                isScreenSharingActive = true;
                updateScreenShareButtonUI();
                addMessageToChat("Screen sharing started. AI will analyze frames from your screen.", 'system');

                // Automatically enable microphone and AI voice
                if (!isRecording) {
                    startRecording(); // This will also update mic button UI
                }
                if (!aiVoiceEnabled) {
                    aiVoiceEnabled = true;
                    localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                    updateSpeakerButtonUI();
                }

                screenVideo.srcObject = screenStream;
                screenVideo.play();

                // Set canvas dimensions to match video stream
                screenVideo.onloadedmetadata = () => {
                    screenCanvas.width = screenVideo.videoWidth;
                    screenCanvas.height = screenVideo.videoHeight;
                };

                // Capture a frame every 5 seconds
                screenCaptureInterval = setInterval(() => {
                    if (screenVideo.videoWidth === 0 || screenVideo.videoHeight === 0) return; // Ensure video is ready
                    const context = screenCanvas.getContext('2d');
                    context.drawImage(screenVideo, 0, 0, screenCanvas.width, screenCanvas.height);
                    latestScreenBase64 = screenCanvas.toDataURL('image/jpeg'); // Store as JPEG Base64
                    // console.log("Captured screen frame:", latestScreenBase64.substring(0, 50) + "...");
                }, 5000); // Capture every 5 seconds

                // Listen for when the user stops sharing via browser controls
                screenStream.oninactive = () => {
                    stopScreenSharing();
                };

            } catch (error) {
                isScreenSharingActive = false;
                updateScreenShareButtonUI();
                if (error.name === 'NotAllowedError') {
                    displayErrorMessage("Screen sharing permission denied.");
                } else if (error.name === 'NotFoundError') {
                    displayErrorMessage("No display source found. Please ensure you have a screen or window to share.");
                } else {
                    displayErrorMessage(`Error starting screen sharing: ${error.message}`);
                }
                console.error("Error starting screen sharing:", error);
            }
        }

        /**
         * Stops screen sharing and clears resources.
         */
        function stopScreenSharing() {
            if (!isScreenSharingActive) return;

            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
                screenVideo.srcObject = null;
            }
            if (screenCaptureInterval) {
                clearInterval(screenCaptureInterval);
                screenCaptureInterval = null;
            }
            latestScreenBase64 = null;
            isScreenSharingActive = false;
            updateScreenShareButtonUI();
            addMessageToChat("Screen sharing stopped.", 'system');

            // Disable microphone and AI voice if they were enabled by screen sharing
            // Note: This simple implementation will turn them off regardless of manual user toggle.
            if (isRecording) {
                stopRecording();
            }
            if (aiVoiceEnabled) {
                aiVoiceEnabled = false;
                localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                updateSpeakerButtonUI();
                if (synth.speaking) synth.cancel();
            }
        }

        // --- Customize Chat Modal Functions ---
        let chatToCustomizeId = null; // Stores the ID of the chat being customized

        /**
         * Opens the customize chat modal for a specific chat.
         * @param {string} chatId The ID of the chat to customize.
         */
        function openCustomizeChatModal(chatId) {
            chatToCustomizeId = chatId;
            const chat = chatSessions[chatId];

            if (!chat) {
                console.error("Chat not found for customization:", chatId);
                return;
            }

            chatNameInput.value = chat.name || '';
            chatPromptInfoTextarea.value = chat.promptInfo || '';
            
            // Set profile picture preview and button visibility
            if (chat.profilePicture) {
                chatProfilePicturePreview.src = chat.profilePicture;
                removeProfilePictureButton.classList.remove('hidden');
            } else {
                chatProfilePicturePreview.src = 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Default
                removeProfilePictureButton.classList.add('hidden');
            }
            
            customizeChatModal.style.display = 'flex';
        }

        /**
         * Closes the customize chat modal.
         */
        function closeCustomizeChatModal() {
            customizeChatModal.style.display = 'none';
            chatToCustomizeId = null; // Clear the ID
            chatProfilePictureInput.value = ''; // Clear file input
        }

        /**
         * Saves the customized chat details.
         */
        function saveCustomizeChat() {
            if (!chatToCustomizeId) return;

            const chat = chatSessions[chatToCustomizeId];
            if (!chat) return;

            chat.name = chatNameInput.value.trim();
            chat.promptInfo = chatPromptInfoTextarea.value.trim();
            // Profile picture is handled by its own event listener on file input

            saveChatSessionsToStorage();
            renderChatList(); // Re-render chat list to show updated name/picture
            closeCustomizeChatModal();
        }

        /**
         * Handles selecting a profile picture for the chat.
         * @param {Event} event The change event from the file input.
         */
        function handleProfilePictureSelection(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                displayErrorMessage("Only image files are supported for profile pictures.");
                chatProfilePictureInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                chatProfilePicturePreview.src = e.target.result;
                removeProfilePictureButton.classList.remove('hidden');
                if (chatToCustomizeId) {
                    chatSessions[chatToCustomizeId].profilePicture = e.target.result;
                    saveChatSessionsToStorage();
                    renderChatList(); // Update the list immediately
                }
            };
            reader.onerror = (error) => {
                console.error("Error reading profile picture file:", error);
                displayErrorMessage("Failed to read profile picture file.");
            };
            reader.readAsDataURL(file);
        }

        /**
         * Removes the profile picture from the current chat.
         */
        function removeProfilePicture() {
            chatProfilePicturePreview.src = 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Set to default
            removeProfilePictureButton.classList.add('hidden');
            chatProfilePictureInput.value = ''; // Clear the file input
            if (chatToCustomizeId) {
                chatSessions[chatToCustomizeId].profilePicture = ''; // Remove from data
                saveChatSessionsToStorage();
                renderChatList(); // Update the list immediately
            }
        }


        // --- Event Listeners ---
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !isRecording) sendMessage();
        });

        settingsButton.addEventListener('click', openSettingsModal);
        closeModalButton.addEventListener('click', closeSettingsModal);
        saveApiKeyButton.addEventListener('click', saveSettings); 
        openSettingsFromPromptButton.addEventListener('click', openSettingsModal);
        
        if(speakerToggleButton) {
            speakerToggleButton.addEventListener('click', () => {
                aiVoiceEnabled = !aiVoiceEnabled;
                localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                updateSpeakerButtonUI();
                if (!aiVoiceEnabled && synth.speaking) synth.cancel();
            });
        }

        if(voiceSelectDropdown) {
            voiceSelectDropdown.addEventListener('change', (event) => {
                selectedVoiceURI = event.target.value;
                localStorage.setItem('selectedVoiceURI', selectedVoiceURI);
            });
        }

        if (imageGenToggleButton) {
            imageGenToggleButton.addEventListener('click', () => {
                isImageGenerationEnabled = !isImageGenerationEnabled;
                localStorage.setItem('isImageGenerationEnabled', isImageGenerationEnabled);
                updateImageGenButtonUI();
            });
        }

        if (shareScreenButton) {
            shareScreenButton.addEventListener('click', () => {
                if (isScreenSharingActive) {
                    stopScreenSharing();
                } else {
                    startScreenSharing();
                }
            });
        }

        if (deepResearchToggleButton) {
            deepResearchToggleButton.addEventListener('click', () => {
                isDeepResearchEnabled = !isDeepResearchEnabled;
                localStorage.setItem('isDeepResearchEnabled', isDeepResearchEnabled);
                updateDeepResearchButtonUI();
            });
        }

        if (canvasToggleButton) {
            canvasToggleButton.addEventListener('click', () => {
                isCanvasEnabled = !isCanvasEnabled;
                localStorage.setItem('isCanvasEnabled', isCanvasEnabled);
                updateCanvasButtonUI();
            });
        }

        window.addEventListener('click', (event) => {
            if (event.target === settingsModal) closeSettingsModal();
            if (event.target === confirmationModal) hideConfirmationModal(); // Close confirmation modal on outside click
            if (event.target === customizeChatModal) closeCustomizeChatModal(); // Close customize chat modal on outside click
        });

        newChatButton.addEventListener('click', () => startNewChat(true, true)); // Pass true to open customize modal

        // File upload event listeners
        uploadButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelection);
        
        // Event listeners for new feature visibility toggles
        if (toggleUploadButton) {
            toggleUploadButton.addEventListener('change', () => {
                showUploadButton = toggleUploadButton.checked;
                localStorage.setItem('showUploadButton', showUploadButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleShareScreenButton) {
            toggleShareScreenButton.addEventListener('change', () => {
                showShareScreenButton = toggleShareScreenButton.checked;
                localStorage.setItem('showShareScreenButton', showShareScreenButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleImageGenButton) {
            toggleImageGenButton.addEventListener('change', () => {
                showImageGenButton = toggleImageGenButton.checked;
                localStorage.setItem('showImageGenButton', showImageGenButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleDeepResearchButton) {
            toggleDeepResearchButton.addEventListener('change', () => {
                showDeepResearchButton = toggleDeepResearchButton.checked;
                localStorage.setItem('showDeepResearchButton', showDeepResearchButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleCanvasButton) {
            toggleCanvasButton.addEventListener('change', () => {
                showCanvasButton = toggleCanvasButton.checked;
                localStorage.setItem('showCanvasButton', showCanvasButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleMicButton) {
            toggleMicButton.addEventListener('change', () => {
                showMicButton = toggleMicButton.checked;
                localStorage.setItem('showMicButton', showMicButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleSpeakerButton) {
            toggleSpeakerButton.addEventListener('change', () => {
                showSpeakerButton = toggleSpeakerButton.checked;
                localStorage.setItem('showSpeakerButton', showSpeakerButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleThinkingButton) {
            toggleThinkingButton.addEventListener('change', () => {
                showThinkingButton = toggleThinkingButton.checked;
                localStorage.setItem('showThinkingButton', showThinkingButton);
                updateButtonVisibilityUI();
                displayCurrentChatHistory(); // Re-render chat messages to apply "Show Thinking" button visibility
            });
        }

        // Customize Chat Modal Event Listeners
        closeCustomizeModalButton.addEventListener('click', closeCustomizeChatModal);
        cancelCustomizeChatButton.addEventListener('click', closeCustomizeChatModal);
        saveCustomizeChatButton.addEventListener('click', saveCustomizeChat);
        selectProfilePictureButton.addEventListener('click', () => chatProfilePictureInput.click());
        chatProfilePictureInput.addEventListener('change', handleProfilePictureSelection);
        removeProfilePictureButton.addEventListener('click', removeProfilePicture);


        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
