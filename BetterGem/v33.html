<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BetterGem AI Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #94a3b8; /* slate-400 */
            border-radius: 4px;
        }
        html.dark ::-webkit-scrollbar-thumb {
            background-color: #475569; /* slate-600 */
        }
        ::-webkit-scrollbar-track {
            background-color: #f1f5f9; /* slate-100 */
        }
        html.dark ::-webkit-scrollbar-track {
            background-color: #1e293b; /* slate-800 */
        }

        /* Chat bubble styles - Removed hardcoded colors to rely on Tailwind */
        .chat-bubble {
            max-width: 75%;
            padding: 10px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            word-wrap: break-word;
            transition: background-color 0.3s, color 0.3s;
            position: relative; /* Needed for absolute positioning of delete button */
        }
        .user-bubble {
            margin-left: auto;
            border-bottom-right-radius: 5px;
        }
        .ai-bubble {
            margin-right: auto;
            border-bottom-left-radius: 5px;
        }
        /* System message bubble style */
        .system-bubble {
            text-align: center;
            font-size: 0.875rem; /* text-sm */
            color: #64748b; /* slate-500 */
            width: 100%;
            max-width: 100%;
            background-color: transparent;
            box-shadow: none;
            margin-left: 0;
            margin-right: 0;
            padding: 5px 0;
        }

        /* Message delete button */
        .delete-message-button {
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* text-xs */
            cursor: pointer;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease-in-out;
        }
        .chat-bubble:hover .delete-message-button {
            opacity: 1; /* Show on hover */
        }
        .delete-message-button:hover {
            background-color: rgba(255, 0, 0, 1);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            margin: auto;
            padding: 20px;
            border: 1px solid #888; /* Fallback border */
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        .close-button {
            float: right;
            font-size: 28px;
            font-weight: bold;
            transition: color 0.3s;
        }
        .close-button:hover,
        .close-button:focus {
            text-decoration: none;
            cursor: pointer;
        }
        /* Active states for buttons */
        .mic-active svg, .speaker-active svg, .screen-sharing-active svg, .deep-research-active svg, .canvas-active svg {
            color: #ef4444; /* red-500 */
        }
        html.dark .mic-active svg, html.dark .speaker-active svg, html.dark .screen-sharing-active svg, html.dark .deep-research-active svg, html.dark .canvas-active svg {
             color: #f87171; /* red-400 */
        }
        /* Image generation toggle active state */
        .image-gen-active svg { /* Target the SVG directly */
            color: #ef4444; /* red-500 */
        }
        html.dark .image-gen-active svg {
            color: #f87171; /* red-400 */
        }

        /* Voice select dropdown width */
        #voice-select-dropdown {
            max-width: 150px; /* Limit width of voice selector */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Chat list item active state */
        .chat-list-item.active {
            background-color: #e2e8f0; /* slate-200 */
            font-weight: 600; /* font-semibold */
        }
        html.dark .chat-list-item.active {
            background-color: #334155; /* slate-700 */
        }

        /* Ensure main content takes remaining height */
        .flex-container {
            display: flex;
            flex: 1; /* Allows it to grow and fill available space */
            overflow: hidden; /* Prevents overflow issues with flex items */
        }

        /* Show thinking button within AI bubble */
        .show-thinking-button {
            background-color: #cbd5e1; /* slate-300 */
            color: #475569; /* slate-700 */
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.75rem; /* text-xs */
            cursor: pointer;
            margin-top: 8px;
            display: inline-block;
            transition: background-color 0.2s;
        }
        .ai-bubble.dark .show-thinking-button {
            background-color: #475569; /* slate-600 */
            color: #e2e8f0; /* slate-200 */
        }
        .show-thinking-button:hover {
            background-color: #94a3b8; /* slate-400 */
        }
        .ai-bubble.dark .show-thinking-button:hover {
            background-color: #64748b; /* slate-500 */
        }
        .thinking-details {
            margin-top: 8px;
            padding: 8px;
            background-color: #e2e8f0; /* slate-200 */
            border-radius: 8px;
            font-size: 0.875rem; /* text-sm */
            color: #475569; /* slate-700 */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            display: none; /* Hidden by default */
        }
        .ai-bubble.dark .thinking-details {
            background-color: #334155; /* slate-700 */
            color: #e2e8f0; /* slate-200 */
        }

        /* Action buttons within chat bubble */
        .message-actions {
            display: flex;
            gap: 8px; /* Space between buttons */
            margin-top: 8px;
            justify-content: flex-end; /* Align to the right for user, left for AI */
        }
        .ai-bubble .message-actions {
            justify-content: flex-start;
        }
        .message-action-button {
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .message-action-button.edit-button {
            background-color: #cbd5e1; /* slate-300 */
            color: #475569; /* slate-700 */
        }
        .message-action-button.edit-button:hover {
            background-color: #94a3b8; /* slate-400 */
        }
        .dark .message-action-button.edit-button {
            background-color: #475569; /* slate-600 */
            color: #e2e8f0; /* slate-200 */
        }
        .dark .message-action-button.edit-button:hover {
            background-color: #64748b; /* slate-500 */
        }

        .message-action-button.regenerate-button {
            background-color: #a78bfa; /* violet-400 */
            color: white;
        }
        .message-action-button.regenerate-button:hover {
            background-color: #8b5cf6; /* violet-500 */
        }
        .dark .message-action-button.regenerate-button {
            background-color: #8b5cf6; /* violet-500 */
        }
        .dark .message-action-button.regenerate-button:hover {
            background-color: #7c3aed; /* violet-600 */
        }

        .message-action-button.save-button {
            background-color: #22c55e; /* green-500 */
            color: white;
        }
        .message-action-button.save-button:hover {
            background-color: #16a34a; /* green-600 */
        }
        .message-action-button.cancel-button {
            background-color: #ef4444; /* red-500 */
            color: white;
        }
        .message-action-button.cancel-button:hover {
            background-color: #dc2626; /* red-600 */
        }

        .edit-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #cbd5e1; /* slate-300 */
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-900 */
            margin-top: 8px;
            resize: vertical;
        }
        .dark .edit-textarea {
            border-color: #475569; /* slate-600 */
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
        }
    </style>
    <script>
        // Apply theme ASAP to avoid FOUC (Flash Of Unstyled Content)
        // This script runs before the DOM is fully loaded, setting the initial theme.
        // The theme is now permanently 'light' unless the user's system prefers dark mode.
        const initialTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        if (initialTheme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        // Remove theme preference from local storage if it exists, as it's no longer user-selectable
        localStorage.removeItem('theme');
    </script>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex flex-col h-screen transition-colors duration-300">

    <header class="bg-slate-800 dark:bg-slate-950 text-white p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center">
            <div class="flex items-baseline space-x-2">
                <h1 class="text-xl font-semibold">BetterGem AI Chat</h1>
                <span class="text-sm text-slate-400 dark:text-slate-500" id="current-model-display"></span>
            </div>
            <button id="settings-button" class="p-2 rounded-md hover:bg-slate-700 dark:hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-slate-500 dark:focus:ring-slate-400">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 0 1 1.45.12l.773.774c.39.39.44 1.002.12 1.45l-.527.737c-.25.35-.272.806-.108 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.11v1.093c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.107 1.204l.527.738c.32.447.27.96-.12 1.45l-.774.773a1.125 1.125 0 0 1-1.449.12l-.738-.527c-.35-.25-.806-.272-1.203-.107-.397.165-.71.505-.78.93l-.15.894c-.09.542-.56.94-1.11.94h-1.094c-.55 0-1.019-.398-1.11-.94l-.149-.894c-.07-.424-.384-.764-.78-.93-.398-.164-.854-.142-1.204.108l-.738.527c-.447.32-.96.27-1.45-.12l-.773-.774a1.125 1.125 0 0 1-.12-1.45l.527-.737c.25-.35.272-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.11v-1.094c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.765-.383.93-.78.165.398.143.854-.108-1.204l-.526-.738a1.125 1.125 0 0 1 .12-1.45l.773-.773a1.125 1.125 0 0 1 1.45-.12l.737.527c.35.25.807.272 1.204.107.397-.165.71-.505.78-.93l.15-.893Z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                </svg>
            </button>
        </div>
    </header>

    <div class="flex-container flex-1 w-full max-w-7xl mx-auto py-4 px-2 sm:px-4">
        <aside class="w-full sm:w-64 bg-white dark:bg-slate-800 shadow rounded-lg p-4 mr-4 flex flex-col flex-shrink-0">
            <h2 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-4">Chats</h2>
            <button id="new-chat-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out mb-4">
                + New Chat
            </button>
            <div id="chat-list" class="flex-1 overflow-y-auto space-y-2">
                </div>
        </aside>

        <main id="chat-container" class="flex-1 flex flex-col">
            <div id="chat-messages" class="flex-1 space-y-4 overflow-y-auto p-4 bg-white dark:bg-slate-800 shadow rounded-lg mb-4">
                </div>

            <div class="bg-white dark:bg-slate-800 p-4 shadow rounded-lg">
                <div id="error-message" class="text-red-500 dark:text-red-400 text-sm mb-2 hidden"></div>
                <div id="api-key-prompt" class="text-amber-600 dark:text-amber-400 text-sm mb-2 hidden">
                    API Key not set. Please <button id="open-settings-from-prompt" class="underline font-semibold">set your API Key</button> in settings.
                </div>
                <div id="uploaded-files-preview" class="flex flex-wrap gap-2 mb-2 hidden"></div>

                <div id="action-buttons-container" class="flex flex-wrap items-center gap-2 mb-4">
                    <button id="upload-button" title="Upload File" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.75 3.75 0 0 1 18 19.5H6.75Z" />
                        </svg>
                    </button>
                    <input type="file" id="file-input" accept="image/*" class="hidden" multiple>

                    <button id="share-screen-button" title="Share Screen with AI" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 17.25v1.007a3 3 0 0 1-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0 1 15 18.257V17.25m6-12V15a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 15V5.25m18 0A2.25 2.25 0 0 0 18.75 3H5.25A2.25 2.25 0 0 0 3 5.25m18 0h.008v.008H21V5.25ZM9 12.75h.008v.008H9v-.008ZM12 12.75h.008v.008H12v-.008ZM15 12.75h.008v.008H15v-.008Z" />
                        </svg>
                    </button>

                    <button id="image-gen-toggle-button" title="Toggle Image Generation" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 15.75 1.5-1.5m1.5 1.5 1.5-1.5m-6.75 6.75h.75A2.25 2.25 0 0 0 4.5 18V9a2.25 2.25 0 0 1 2.25-2.25h10.5A2.25 2.25 0 0 1 19.5 9v9a2.25 2.25 0 0 0 2.25 2.25h.75m-14.25-10.5h.008v.008H7.5v-.008Zm6.75 0h.008v.008H14.25v-.008Z" />
                        </svg>
                    </button>

                    <button id="deep-research-toggle-button" title="Toggle Deep Research" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v6m3-3h-6"/>
                        </svg>
                    </button>

                    <button id="canvas-toggle-button" title="Toggle Canvas Mode" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12c0 1.01-.195 1.98-.546 2.917a1.05 1.05 0 0 0-.759-.759 1.05 1.05 0 0 0-1.992.45c-.407 1.132-1.49 2.064-2.809 2.576a1.05 1.05 0 0 0-1.086.112A4.5 4.5 0 0 1 12 18.75c-2.34 0-4.24-1.9-4.5-4.24a1.05 1.05 0 0 0-.112-1.086A5.25 5.25 0 0 1 7.25 12c0-1.01.195-1.98.546-2.917a1.05 1.05 0 0 0 .759-.759 1.05 1.05 0 0 0 1.992.45c.407 1.132 1.49 2.064 2.809 2.576a1.05 1.05 0 0 0 1.086.112A4.5 4.5 0 0 1 12 5.25c2.34 0 4.24 1.9 4.5 4.24a1.05 1.05 0 0 0 .112 1.086A5.25 5.25 0 0 1 18.75 12Z" />
                        </svg>
                    </button>

                    <button id="mic-button" title="Toggle Microphone" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg id="mic-icon-idle" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256"><path d="M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,151.6V240a8,8,0,0,1-16,0V215.6A80.07,80.07,0,0,1,48,128a8,8,0,0,1,16,0a64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.07,80.07,0,0,1,136,215.6Z"></path></svg>
                        <svg id="mic-icon-active" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 256 256" class="hidden"><path d="M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,151.6V240a8,8,0,0,1-16,0V215.6A80.07,80.07,0,0,1,48,128a8,8,0,0,1,16,0a64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.07,80.07,0,0,1,136,215.6Z"></path></svg>
                    </button>
                    <button id="speaker-toggle-button" title="Toggle AI Voice" class="p-3 rounded-lg border border-slate-300 dark:border-slate-600 hover:bg-slate-200 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 text-slate-600 dark:text-slate-300">
                        <svg id="speaker-icon-on" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" class="hidden"><path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-.708.707A7.476 7.476 0 0 1 13.025 8c0 2.071-.84 3.946-2.197 5.303l.708.707z"/><path d="M10.121 12.596A6.48 6.48 0 0 0 12.025 8a6.48 6.48 0 0 0-1.904-4.596l-.707.707A5.483 5.483 0 0 1 11.025 8a5.483 5.483 0 0 1-1.61 3.89l.706.706z"/><path d="M8.707 11.182A4.486 4.486 0 0 0 10.025 8a4.486 4.486 0 0 0-1.318-3.182L8 5.525A3.489 3.489 0 0 1 9.025 8 3.49 3.49 0 0 1 8 10.475l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06z"/></svg>
                        <svg id="speaker-icon-off" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10.5H1.5A.5.5 0 0 1 1 10V6a.5.5 0 0 1 .5-.5h2.325l2.363-1.89a.5.5 0 0 1 .529-.06zm7.137 2.096a.5.5 0 0 1 0 .708L12.207 8l1.647 1.646a.5.5 0 0 1-.708.708L11.5 8.707l-1.646 1.647a.5.5 0 0 1-.708-.708L10.793 8 9.146 6.354a.5.5 0 1 1 .708-.708L11.5 7.293l1.646-1.647a.5.5 0 0 1 .708 0z"/></svg>
                    </button>
                    <select id="voice-select-dropdown" title="Select AI Voice" class="p-3 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none hidden">
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <input type="text" id="message-input" class="flex-1 p-3 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Type or say your message...">
                    <button id="send-button" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-5 rounded-lg shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                </div>
                <div id="loading-indicator" class="mt-2 text-sm text-slate-500 dark:text-slate-400 hidden">
                    AI is thinking...
                </div>
            </div>
        </main>
    </div>

    <div id="settings-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-slate-700 dark:text-slate-200">Settings</h2>
                <span id="close-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            
            <div class="mb-4">
                <label for="api-key-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Gemini API Key:</label>
                <input type="password" id="api-key-input" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Enter your API Key">
                <button id="save-api-key-button" class="mt-3 w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out">
                    Save Settings
                </button>
                 <p id="api-key-status" class="text-xs mt-2 text-slate-500 dark:text-slate-400"></p>
            </div>

            <div class="mb-4">
                <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-2">Feature Visibility</h3>
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <label for="toggle-upload-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Upload Button:</label>
                        <input type="checkbox" id="toggle-upload-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-share-screen-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Share Screen Button:</label>
                        <input type="checkbox" id="toggle-share-screen-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-image-gen-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Image Generation Button:</label>
                        <input type="checkbox" id="toggle-image-gen-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-deep-research-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Deep Research Button:</label>
                        <input type="checkbox" id="toggle-deep-research-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-canvas-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Canvas Mode Button:</label>
                        <input type="checkbox" id="toggle-canvas-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-mic-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show Microphone Button:</label>
                        <input type="checkbox" id="toggle-mic-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-speaker-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show AI Voice Button:</label>
                        <input type="checkbox" id="toggle-speaker-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-thinking-button" class="text-sm font-medium text-slate-700 dark:text-slate-300">Show "Show Thinking" Button:</label>
                        <input type="checkbox" id="toggle-thinking-button" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="customize-chat-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-semibold text-slate-700 dark:text-slate-200">Customize Chat</h2>
                <span id="close-customize-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            
            <div class="mb-4">
                <label for="chat-name-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Chat Name:</label>
                <input type="text" id="chat-name-input" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none" placeholder="Enter chat name">
            </div>

            <div class="mb-4">
                <label for="chat-profile-picture-input" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Profile Picture:</label>
                <div class="flex items-center space-x-4">
                    <input type="file" id="chat-profile-picture-input" accept="image/*" class="hidden">
                    <button id="select-profile-picture-button" class="bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-200 py-2 px-4 rounded-md hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors duration-150">
                        Select Image
                    </button>
                    <img id="chat-profile-picture-preview" class="w-16 h-16 rounded-full object-cover border border-slate-300 dark:border-slate-600" src="https://placehold.co/64x64/e2e8f0/64748b?text=AI" alt="Profile Preview">
                    <button id="remove-profile-picture-button" class="text-red-500 hover:text-red-700 text-sm hidden">Remove</button>
                </div>
            </div>

            <div class="mb-4">
                <label for="chat-prompt-info-textarea" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Prompt Information (System Message):</label>
                <textarea id="chat-prompt-info-textarea" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none h-32 resize-y" placeholder="Enter any specific instructions or context for the AI that will be sent at the start of each conversation."></textarea>
            </div>

            <div class="mb-6">
                <label for="ai-model-select" class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">AI Model:</label>
                <select id="ai-model-select" class="w-full p-2 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-md focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 focus:border-transparent outline-none">
                    </select>
                <p id="model-select-status" class="text-xs mt-1 text-slate-500 dark:text-slate-400 hidden"></p>
            </div>

            <div class="flex justify-end space-x-4">
                <button id="cancel-customize-chat-button" class="px-4 py-2 rounded-md bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-200 hover:bg-slate-400 dark:hover:bg-slate-700 transition-colors duration-150">
                    Cancel
                </button>
                <button id="save-customize-chat-button" class="px-4 py-2 rounded-md bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-150">
                    Save
                </button>
            </div>
        </div>
    </div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content bg-white dark:bg-slate-800 border-slate-300 dark:border-slate-700 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6">
                <h2 id="confirmation-title" class="text-xl font-semibold text-slate-700 dark:text-slate-200">Confirm Action</h2>
                <span id="close-confirmation-modal-button" class="close-button text-slate-400 dark:text-slate-500 hover:text-slate-700 dark:hover:text-slate-300 cursor-pointer">&times;</span>
            </div>
            <p id="confirmation-message" class="text-slate-700 dark:text-slate-300 mb-6">Are you sure you want to proceed?</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-confirmation-button" class="px-4 py-2 rounded-md bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-200 hover:bg-slate-400 dark:hover:bg-slate-700 transition-colors duration-150">
                    Cancel
                </button>
                <button id="confirm-action-button" class="px-4 py-2 rounded-md bg-red-500 text-white hover:bg-red-600 transition-colors duration-150">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <video id="screen-video" class="hidden" autoplay playsinline></video>
    <canvas id="screen-canvas" class="hidden"></canvas>

    <script>
        // DOM Elements
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const micIconIdle = document.getElementById('mic-icon-idle');
        const micIconActive = document.getElementById('mic-icon-active');
        const speakerToggleButton = document.getElementById('speaker-toggle-button');
        const speakerIconOn = document.getElementById('speaker-icon-on');
        const speakerIconOff = document.getElementById('speaker-icon-off');
        const voiceSelectDropdown = document.getElementById('voice-select-dropdown');
        const chatMessages = document.getElementById('chat-messages');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessageDiv = document.getElementById('error-message');
        
        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key-button');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiKeyPrompt = document.getElementById('api-key-prompt');
        const openSettingsFromPromptButton = document.getElementById('open-settings-from-prompt');

        // New DOM Elements for chat list
        const newChatButton = document.getElementById('new-chat-button');
        const chatListContainer = document.getElementById('chat-list');

        // New DOM Elements for file upload and image generation
        const uploadButton = document.getElementById('upload-button');
        const fileInput = document.getElementById('file-input');
        const uploadedFilesPreview = document.getElementById('uploaded-files-preview');
        const imageGenToggleButton = document.getElementById('image-gen-toggle-button');
        const shareScreenButton = document.getElementById('share-screen-button'); // New screen share button
        const deepResearchToggleButton = document.getElementById('deep-research-toggle-button'); // New deep research button
        const canvasToggleButton = document.getElementById('canvas-toggle-button'); // New canvas button

        const screenVideo = document.getElementById('screen-video'); // Hidden video element
        const screenCanvas = document.getElementById('screen-canvas'); // Hidden canvas element

        // Custom Confirmation Modal Elements
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmActionButton = document.getElementById('confirm-action-button');
        const cancelConfirmationButton = document.getElementById('cancel-confirmation-button');
        const closeConfirmationModalButton = document.getElementById('close-confirmation-modal-button');

        // New DOM elements for feature visibility toggles in settings
        const toggleUploadButton = document.getElementById('toggle-upload-button');
        const toggleShareScreenButton = document.getElementById('toggle-share-screen-button');
        const toggleImageGenButton = document.getElementById('toggle-image-gen-button');
        const toggleDeepResearchButton = document.getElementById('toggle-deep-research-button');
        const toggleCanvasButton = document.getElementById('toggle-canvas-button');
        const toggleMicButton = document.getElementById('toggle-mic-button');
        const toggleSpeakerButton = document.getElementById('toggle-speaker-button');
        const toggleThinkingButton = document.getElementById('toggle-thinking-button');

        // DOM Elements for Customize Chat Modal
        const customizeChatModal = document.getElementById('customize-chat-modal');
        const closeCustomizeModalButton = document.getElementById('close-customize-modal-button');
        const chatNameInput = document.getElementById('chat-name-input');
        const chatProfilePictureInput = document.getElementById('chat-profile-picture-input');
        const selectProfilePictureButton = document.getElementById('select-profile-picture-button');
        const removeProfilePictureButton = document.getElementById('remove-profile-picture-button');
        const chatProfilePicturePreview = document.getElementById('chat-profile-picture-preview');
        const chatPromptInfoTextarea = document.getElementById('chat-prompt-info-textarea');
        const saveCustomizeChatButton = document.getElementById('save-customize-chat-button');
        const cancelCustomizeChatButton = document.getElementById('cancel-customize-chat-button');
        
        // New DOM elements for AI Model Selection
        const aiModelSelect = document.getElementById('ai-model-select');
        const modelSelectStatus = document.getElementById('model-select-status');
        const currentModelDisplay = document.getElementById('current-model-display');


        // State Variables
        // Stores all chat sessions: { chatId: { history: chatHistoryArray, name: 'Chat Name', profilePicture: 'data:image/...', promptInfo: '...', selectedModel: '...' } }
        let chatSessions = {}; 
        let currentChatId = null; // ID of the currently active chat
        let chatHistory = []; // Reference to the chat history of the currentChatId
        let geminiApiKey = localStorage.getItem('geminiApiKey') || '';
        let aiVoiceEnabled = localStorage.getItem('aiVoiceEnabled') === 'true';
        let isImageGenerationEnabled = localStorage.getItem('isImageGenerationEnabled') === 'true'; // New state for image generation
        let isScreenSharingActive = false; // New state for screen sharing
        let isDeepResearchEnabled = localStorage.getItem('isDeepResearchEnabled') === 'true'; // New state for deep research
        let isCanvasEnabled = localStorage.getItem('isCanvasEnabled') === 'true'; // New state for canvas
        let screenStream = null; // Stores the MediaStream object
        let screenCaptureInterval = null; // Stores the interval ID for screen capture
        let latestScreenBase64 = null; // Stores the latest captured screen frame as Base64
        let selectedVoiceURI = localStorage.getItem('selectedVoiceURI') || '';
        let isRecording = false;
        let availableVoices = [];
        // Stores objects like { data: base64String, mimeType: 'image/jpeg' }.
        // `data` now stores the full data URL (e.g., "data:image/png;base64,...")
        let selectedFiles = []; 
        let availableAiModels = []; // Stores fetched models globally

        // Feature visibility states (enabled by default)
        // Initialize from localStorage, defaulting to true if not found
        let showUploadButton = localStorage.getItem('showUploadButton') !== 'false';
        let showShareScreenButton = localStorage.getItem('showShareScreenButton') !== 'false';
        let showImageGenButton = localStorage.getItem('showImageGenButton') !== 'false';
        let showDeepResearchButton = localStorage.getItem('showDeepResearchButton') !== 'false';
        let showCanvasButton = localStorage.getItem('showCanvasButton') !== 'false';
        let showMicButton = localStorage.getItem('showMicButton') !== 'false';
        let showSpeakerButton = localStorage.getItem('showSpeakerButton') !== 'false';
        let showThinkingButton = localStorage.getItem('showThinkingButton') !== 'false';


        // Speech Recognition
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                messageInput.value = speechResult;
                stopRecording();
                // Automatically send message after speech recognition if not empty
                if (messageInput.value.trim() !== '' || selectedFiles.length > 0 || isScreenSharingActive) {
                    sendMessage();
                }
            };
            recognition.onerror = (event) => {
                console.error("Speech recognition error", event.error);
                let errorMsg = `Mic error: ${event.error}`;
                if (event.error === 'no-speech') errorMsg = "No speech detected. Please try again.";
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') errorMsg = "Microphone access denied. Please enable it in your browser settings.";
                displayErrorMessage(errorMsg);
                stopRecording();
            };
            recognition.onend = () => { if (isRecording) stopRecording(); };
        } else {
            console.warn("Speech Recognition API not supported.");
            // Hide mic button if API not supported
            if(micButton) micButton.style.display = 'none';
        }

        // Speech Synthesis
        const synth = window.speechSynthesis;

        function populateVoiceList() {
            availableVoices = synth.getVoices();
            voiceSelectDropdown.innerHTML = ''; // Clear existing options
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Default Voice';
            voiceSelectDropdown.appendChild(defaultOption);

            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.setAttribute('data-lang', voice.lang);
                option.setAttribute('data-name', voice.name);
                option.value = voice.voiceURI;
                if (voice.voiceURI === selectedVoiceURI) {
                    option.selected = true;
                }
                voiceSelectDropdown.appendChild(option);
            });
            voiceSelectDropdown.value = selectedVoiceURI; // re-apply selected URI
        }
        
        if (synth) {
            populateVoiceList();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoiceList;
            }
        } else {
            console.warn("Speech Synthesis API not supported.");
            // Hide speaker and voice dropdown if API not supported
            if(speakerToggleButton) speakerToggleButton.style.display = 'none';
            if(voiceSelectDropdown) voiceSelectDropdown.style.display = 'none';
        }

        /**
         * Speaks the given text using the selected AI voice.
         * @param {string} text - The text to speak.
         */
        function speakText(text) {
            if (!aiVoiceEnabled || !synth || !text) return;
            if (synth.speaking) {
                synth.cancel(); // Stop any ongoing speech
            }
            const utterThis = new SpeechSynthesisUtterance(text);
            utterThis.onerror = (event) => console.error('SpeechSynthesisUtterance.onerror', event);

            if (selectedVoiceURI) {
                const voice = availableVoices.find(v => v.voiceURI === selectedVoiceURI);
                if (voice) utterThis.voice = voice;
            }
            synth.speak(utterThis);
        }
        
        /**
         * Updates the UI for the speaker toggle button and voice select dropdown.
         */
        function updateSpeakerButtonUI() {
            if (aiVoiceEnabled) {
                speakerIconOn.classList.remove('hidden');
                speakerIconOff.classList.add('hidden');
                voiceSelectDropdown.classList.remove('hidden');
                speakerToggleButton.classList.add('speaker-active');
            } else {
                speakerIconOn.classList.add('hidden');
                speakerIconOff.classList.remove('hidden');
                voiceSelectDropdown.classList.add('hidden');
                speakerToggleButton.classList.remove('speaker-active');
            }
        }

        /**
         * Updates the UI for the image generation toggle button.
         */
        function updateImageGenButtonUI() {
            if (isImageGenerationEnabled) {
                imageGenToggleButton.classList.add('image-gen-active');
            } else {
                imageGenToggleButton.classList.remove('image-gen-active');
            }
        }

        /**
         * Updates the UI for the screen sharing button.
         */
        function updateScreenShareButtonUI() {
            if (isScreenSharingActive) {
                shareScreenButton.classList.add('screen-sharing-active');
            } else {
                shareScreenButton.classList.remove('screen-sharing-active');
            }
        }

        /**
         * Updates the UI for the deep research toggle button.
         */
        function updateDeepResearchButtonUI() {
            if (isDeepResearchEnabled) {
                deepResearchToggleButton.classList.add('deep-research-active');
            } else {
                deepResearchToggleButton.classList.remove('deep-research-active');
            }
        }

        /**
         * Updates the UI for the canvas toggle button.
         */
        function updateCanvasButtonUI() {
            if (isCanvasEnabled) {
                canvasToggleButton.classList.add('canvas-active');
            } else {
                canvasToggleButton.classList.remove('canvas-active');
            }
        }

        /**
         * Updates the visibility of all action buttons based on settings.
         */
        function updateButtonVisibilityUI() {
            // Apply display style based on feature visibility flags
            if (uploadButton) uploadButton.style.display = showUploadButton ? 'block' : 'none';
            if (shareScreenButton) shareScreenButton.style.display = showShareScreenButton ? 'block' : 'none';
            if (imageGenToggleButton) imageGenToggleButton.style.display = showImageGenButton ? 'block' : 'none';
            if (deepResearchToggleButton) deepResearchToggleButton.style.display = showDeepResearchButton ? 'block' : 'none';
            if (canvasToggleButton) canvasToggleButton.style.display = showCanvasButton ? 'block' : 'none';
            if (micButton) micButton.style.display = showMicButton ? 'block' : 'none';
            if (speakerToggleButton) speakerToggleButton.style.display = showSpeakerButton ? 'block' : 'none';

            // Also update the state of the checkboxes in the settings modal
            if (toggleUploadButton) toggleUploadButton.checked = showUploadButton;
            if (toggleShareScreenButton) toggleShareScreenButton.checked = showShareScreenButton;
            if (toggleImageGenButton) toggleImageGenButton.checked = showImageGenButton;
            if (toggleDeepResearchButton) toggleDeepResearchButton.checked = showDeepResearchButton;
            if (toggleCanvasButton) toggleCanvasButton.checked = showCanvasButton;
            if (toggleMicButton) toggleMicButton.checked = showMicButton;
            if (toggleSpeakerButton) toggleSpeakerButton.checked = showSpeakerButton;
            if (toggleThinkingButton) toggleThinkingButton.checked = showThinkingButton;


            // Ensure voice select dropdown visibility is linked to speaker button
            if (!showSpeakerButton) {
                voiceSelectDropdown.classList.add('hidden');
            } else {
                // Re-apply original logic for voice select dropdown based on aiVoiceEnabled
                updateSpeakerButtonUI();
            }
        }

        // --- Initialization ---
        /**
         * Initializes the application state and UI.
         */
        function initializeApp() {
            // Load feature visibility settings
            showUploadButton = localStorage.getItem('showUploadButton') !== 'false';
            showShareScreenButton = localStorage.getItem('showShareScreenButton') !== 'false';
            showImageGenButton = localStorage.getItem('showImageGenButton') !== 'false';
            showDeepResearchButton = localStorage.getItem('showDeepResearchButton') !== 'false';
            showCanvasButton = localStorage.getItem('showCanvasButton') !== 'false';
            showMicButton = localStorage.getItem('showMicButton') !== 'false';
            showSpeakerButton = localStorage.getItem('showSpeakerButton') !== 'false';
            showThinkingButton = localStorage.getItem('showThinkingButton') !== 'false';

            // Apply feature visibility
            updateButtonVisibilityUI();

            // AI Voice setup
            updateSpeakerButtonUI();
            // Image Generation setup
            updateImageGenButtonUI();
            // Screen sharing setup
            updateScreenShareButtonUI();
            // Deep Research setup
            updateDeepResearchButtonUI();
            // Canvas setup
            updateCanvasButtonUI();

            // Load chat sessions and set up initial chat
            loadChatSessionsFromStorage();
            updateApiKeyStatus(); // Update API key status in settings modal
            updateCurrentModelDisplay(); // Update current model in header

            // Check API key and disable input if not set
            if (!geminiApiKey) {
                apiKeyPrompt.classList.remove('hidden');
                sendButton.disabled = true;
                if(micButton) micButton.disabled = true;
                if(uploadButton) uploadButton.disabled = true; // Disable upload if no API key
                if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen if no API key
                if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share if no API key
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research if no API key
                if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas if no API key
                // Add a system message if no API key is set and no chat history exists
                if (chatHistory.length === 0) {
                    addMessageToChat("Welcome! Please set your Gemini API Key in the settings to start chatting.", 'system');
                }
            } else {
                apiKeyPrompt.classList.add('hidden');
                sendButton.disabled = false;
                if(micButton) micButton.disabled = false;
                if(uploadButton) uploadButton.disabled = false; // Enable upload if API key
                if(imageGenToggleButton) imageGenToggleButton.disabled = false; // Enable image gen if API key
                if(shareScreenButton) shareScreenButton.disabled = false; // Enable screen share if API key
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = false; // Enable deep research if API key
                if(canvasToggleButton) canvasToggleButton.disabled = false; // Enable canvas if API key
                // Only add welcome message if the current chat is truly empty
                if (chatHistory.length === 0) {
                    addMessageToChat("Welcome! How can I help you today?", 'system');
                }
            }
            // Display history for the current chat
            displayCurrentChatHistory();
        }

        /**
         * Toggles the visibility of the thinking details for a given message.
         * @param {HTMLElement} buttonElement - The "Show Thinking" button that was clicked.
         */
        function toggleThinkingDetails(buttonElement) {
            const thinkingDetails = buttonElement.nextElementSibling; // Get the next sibling, which should be the thinking details div
            if (thinkingDetails && thinkingDetails.classList.contains('thinking-details')) {
                if (thinkingDetails.style.display === 'block') {
                    thinkingDetails.style.display = 'none';
                    buttonElement.textContent = 'Show Thinking';
                } else {
                    thinkingDetails.style.display = 'block';
                    buttonElement.textContent = 'Hide Thinking';
                }
            }
        }

        /**
         * Adds a message bubble to the chat display.
         * @param {string} message - The text content of the message.
         * @param {string} sender - The sender of the message ('user', 'ai', or 'system').
         * @param {boolean} [isLoading=false] - True if this is a temporary loading message.
         * @param {Array<Object>} [files=[]] - Array of file objects ({data: base64DataUrl, mimeType: string}) for display.
         * @param {number} [messageIndex=-1] - The index of the message in chatHistory, for deletion, editing, regeneration.
         * @param {number} [totalGenerations=1] - Total number of generations for an AI message.
         * @param {number} [currentGenIndex=0] - Current generation index for an AI message.
         */
        function addMessageToChat(message, sender, isLoading = false, files = [], messageIndex = -1, totalGenerations = 1, currentGenIndex = 0) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-bubble');
            messageElement.dataset.messageIndex = messageIndex; // Store index for easy lookup

            if (sender === 'user') {
                messageElement.classList.add('bg-blue-500', 'text-white', 'dark:bg-blue-700', 'dark:text-white', 'user-bubble');
            } else if (sender === 'ai') {
                messageElement.classList.add('bg-gray-200', 'dark:bg-slate-700', 'text-slate-800', 'dark:text-slate-200', 'ai-bubble');
            } else { // system messages
                messageElement.classList.add('system-bubble');
            }
            
            // Add message text container
            const textContentContainer = document.createElement('div');
            textContentContainer.classList.add('message-text-content'); // Add a class to target text
            textContentContainer.textContent = message;
            messageElement.appendChild(textContentContainer);

            // Add image previews if files are present
            if (files && files.length > 0) {
                files.forEach(file => {
                    if (file.mimeType.startsWith('image/')) {
                        const img = document.createElement('img');
                        img.src = file.data; 
                        img.alt = 'Uploaded image';
                        img.classList.add('mt-2', 'rounded-md', 'max-w-full', 'h-auto', 'max-h-48', 'object-contain');
                        messageElement.appendChild(img);
                    }
                });
            }

            // Add action buttons (Edit, Regenerate, Show Thinking, and Generation Navigation)
            if (sender !== 'system' && !isLoading) {
                const actionsContainer = document.createElement('div');
                actionsContainer.classList.add('message-actions');

                // Edit Button
                const editButton = document.createElement('button');
                editButton.classList.add('message-action-button', 'edit-button');
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => editMessage(messageIndex));
                actionsContainer.appendChild(editButton);

                // Regenerate Button (only for AI messages)
                if (sender === 'ai') {
                    const regenerateButton = document.createElement('button');
                    regenerateButton.classList.add('message-action-button', 'regenerate-button');
                    regenerateButton.textContent = 'Regenerate';
                    regenerateButton.addEventListener('click', () => showConfirmationModal('Regenerate Response', 'Are you sure you want to regenerate this AI response? This will delete all subsequent messages.', () => regenerateResponse(messageIndex)));
                    actionsContainer.appendChild(regenerateButton);

                    // Generation Navigation (only for AI messages if multiple generations exist)
                    if (totalGenerations > 1) {
                        const navContainer = document.createElement('div');
                        navContainer.classList.add('flex', 'items-center', 'space-x-1');

                        const prevButton = document.createElement('button');
                        prevButton.textContent = '<';
                        prevButton.classList.add('message-action-button', 'bg-slate-300', 'dark:bg-slate-600', 'text-slate-800', 'dark:text-slate-200');
                        prevButton.disabled = currentGenIndex === 0;
                        prevButton.addEventListener('click', () => switchGeneration(messageIndex, currentGenIndex - 1));
                        navContainer.appendChild(prevButton);

                        const genText = document.createElement('span');
                        genText.textContent = `${currentGenIndex + 1}/${totalGenerations}`;
                        genText.classList.add('text-xs', 'text-slate-600', 'dark:text-slate-300');
                        navContainer.appendChild(genText);

                        const nextButton = document.createElement('button');
                        nextButton.textContent = '>';
                        nextButton.classList.add('message-action-button', 'bg-slate-300', 'dark:bg-slate-600', 'text-slate-800', 'dark:text-slate-200');
                        nextButton.disabled = currentGenIndex === totalGenerations - 1;
                        nextButton.addEventListener('click', () => switchGeneration(messageIndex, currentGenIndex + 1));
                        navContainer.appendChild(nextButton);

                        actionsContainer.appendChild(navContainer);
                    }
                }

                // Show Thinking Button (only for AI messages and if enabled in settings)
                if (sender === 'ai' && showThinkingButton) {
                    const showThinkingButtonElement = document.createElement('button');
                    showThinkingButtonElement.classList.add('message-action-button', 'show-thinking-button');
                    showThinkingButtonElement.textContent = 'Show Thinking';
                    showThinkingButtonElement.addEventListener('click', (event) => {
                        toggleThinkingDetails(event.target);
                    });
                    actionsContainer.appendChild(showThinkingButtonElement);

                    const thinkingDetailsDiv = document.createElement('div');
                    thinkingDetailsDiv.classList.add('thinking-details');
                    thinkingDetailsDiv.textContent = 'Detailed thinking process not available via current API.';
                    messageElement.appendChild(thinkingDetailsDiv); // Append outside actions container
                }
                
                messageElement.appendChild(actionsContainer);
            }

            // Add delete button (positioned absolutely, so outside actions container)
            if (sender !== 'system' && !isLoading) {
                const deleteMsgButton = document.createElement('button');
                deleteMsgButton.classList.add('delete-message-button');
                deleteMsgButton.textContent = 'X';
                deleteMsgButton.title = 'Delete message';
                deleteMsgButton.addEventListener('click', () => showConfirmationModal('Delete Message', 'Are you sure you want to delete this message?', () => deleteMessageConfirmed(messageIndex)));
                messageElement.appendChild(deleteMsgButton);
            }

            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (isLoading) messageElement.setAttribute('id', 'loading-bubble');
        }


        /**
         * Clears any displayed error messages.
         */
        function clearErrorMessage() {
            errorMessageDiv.textContent = '';
            errorMessageDiv.classList.add('hidden');
        }

        /**
         * Displays an error message temporarily.
         * @param {string} message - The error message to display.
         */
        function displayErrorMessage(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.classList.remove('hidden');
            setTimeout(clearErrorMessage, 6000); // Hide after 6 seconds
        }

        /**
         * Formats a subset of chat history for the Gemini API.
         * This function handles the new 'generations' structure for 'model' roles.
         * @param {Array<Object>} historySubset - The array of message objects to format.
         * @returns {Array<Object>} The formatted array of message objects ready for the API.
         */
        function formatChatHistoryForApi(historySubset) {
            return historySubset.map(message => {
                if (message.role === 'user' || message.role === 'system') {
                    // User and system messages are already in the correct format
                    return { role: message.role, parts: message.parts };
                } else if (message.role === 'model' && message.generations && message.generations.length > 0) {
                    // For model messages, use the parts from the current generation
                    const currentGeneration = message.generations[message.currentGenerationIndex || 0]; // Default to 0 if not set
                    return { role: message.role, parts: currentGeneration.parts };
                }
                // Fallback for any unexpected message structure, though should ideally not occur
                return null; 
            }).filter(msg => msg !== null); // Filter out any nulls if invalid messages somehow creep in
        }

        /**
         * Sends the user's message to the Gemini API and handles the response.
         */
        async function sendMessage() {
            const messageText = messageInput.value.trim();
            // Only send if there's text, selected files, or screen sharing is active
            if (!messageText && selectedFiles.length === 0 && !isScreenSharingActive) return;

            if (!geminiApiKey) {
                displayErrorMessage("API Key is not set. Please set it in settings.");
                apiKeyPrompt.classList.remove('hidden');
                return;
            }
            clearErrorMessage();

            // Construct parts for the API payload for user message
            const userMessagePartsForAPI = []; // This will be sent to API
            const userMessagePartsForDisplay = []; // This will be used for addMessageToChat

            if (messageText) {
                userMessagePartsForAPI.push({ text: messageText });
                userMessagePartsForDisplay.push({ text: messageText });
            }
            selectedFiles.forEach(file => {
                const base64Only = file.data.split(',')[1];
                userMessagePartsForAPI.push({ inlineData: { mimeType: file.mimeType, data: base64Only } });
                userMessagePartsForDisplay.push({ data: file.data, mimeType: file.mimeType }); // Full data URL for display
            });
            if (isScreenSharingActive && latestScreenBase64) {
                userMessagePartsForAPI.push({ inlineData: { mimeType: "image/jpeg", data: latestScreenBase64.split(',')[1] } });
                userMessagePartsForDisplay.push({ data: latestScreenBase64, mimeType: "image/jpeg" }); // Full data URL for display
                latestScreenBase64 = null; // Clear after sending
            }

            // Create the user message object for *this* turn
            const currentUserMessageObject = { role: "user", parts: userMessagePartsForAPI };

            // Add this user message to the *local* chat history
            chatHistory.push(currentUserMessageObject);
            
            // Extract text and files for displaying the user message
            let displayMessageText = '';
            const displayFiles = [];
            userMessagePartsForDisplay.forEach(part => {
                if (part.text) {
                    displayMessageText += part.text;
                } else if (part.data && part.mimeType) {
                    displayFiles.push({ data: part.data, mimeType: part.mimeType });
                }
            });
            addMessageToChat(displayMessageText, 'user', false, displayFiles, chatHistory.length - 1);

            saveChatSessionsToStorage();

            // Clear input and selected files *after* adding to history
            messageInput.value = '';
            selectedFiles = [];
            uploadedFilesPreview.innerHTML = '';
            uploadedFilesPreview.classList.add('hidden');

            sendButton.disabled = true;
            if(micButton) micButton.disabled = true;
            if(speakerToggleButton) speakerToggleButton.disabled = true;
            if(uploadButton) uploadButton.disabled = true; // Disable upload button during sending
            if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen button during sending
            if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share button during sending
            if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research if no API key
            if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas if no API key


            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "AI is thinking...";
            addMessageToChat("Thinking...", 'ai', true); // Add a temporary loading message

            try {
                // Construct chat history for API call:
                let chatHistoryForApi = [...chatHistory]; // Now includes the user's latest message

                // Prepend prompt info if it exists
                const currentChat = chatSessions[currentChatId];
                const promptInfo = currentChat ? currentChat.promptInfo : '';
                if (promptInfo) {
                    chatHistoryForApi.unshift({ role: "system", parts: [{ text: promptInfo }] });
                }

                // Get the selected model for the current chat
                const selectedModelForChat = currentChat ? currentChat.selectedModel : 'gemini-1.5-flash-latest';

                // 1. Call Gemini for text response
                const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModelForChat}:generateContent?key=${geminiApiKey}`;
                // Use the helper function to format chat history for the API
                const textPayload = { contents: formatChatHistoryForApi(chatHistoryForApi) };

                const textResponse = await fetch(textApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(textPayload)
                });

                if (!textResponse.ok) {
                    const errorData = await textResponse.json();
                    let detailedError = `Text AI Error: ${textResponse.status}`;
                    if (errorData && errorData.error && errorData.error.message) detailedError += ` - ${errorData.error.message}`;
                    throw new Error(detailedError);
                }

                const textResult = await textResponse.json();
                let aiResponseText = "Sorry, I couldn't get a text response.";
                if (textResult.candidates && textResult.candidates[0]?.content?.parts?.[0]?.text) {
                    aiResponseText = textResult.candidates[0].content.parts[0].text;
                } else if (textResult.promptFeedback?.blockReason) {
                     aiResponseText = `Text response blocked: ${textResult.promptFeedback.blockReason}.`;
                }

                // Append messages about unavailable features if toggled
                if (isDeepResearchEnabled) {
                    aiResponseText += "\n\n(Note: Deep Research is not available via the current API.)";
                }
                if (isCanvasEnabled) {
                    aiResponseText += "\n\n(Note: Canvas output is not available via the current API.)";
                }

                // 2. If image generation is enabled, call Imagen for image
                let generatedImageForDisplay = null;
                let generatedImageForHistory = null;

                if (isImageGenerationEnabled && messageText) { // Only generate image if there's a text prompt
                    loadingIndicator.textContent = "AI is generating image..."; // Update loading message
                    try {
                        const imagePayload = { instances: { prompt: messageText }, parameters: { "sampleCount": 1} };
                        const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${geminiApiKey}`;

                        const imageResponse = await fetch(imageApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(imagePayload)
                        });

                        if (!imageResponse.ok) {
                            const errorData = await imageResponse.json();
                            throw new Error(`Image API Error: ${imageResponse.status} - ${errorData.error?.message || 'Unknown error'}`);
                        }

                        const imageResult = await imageResponse.json();
                        if (imageResult.predictions && imageResult.predictions.length > 0 && imageResult.predictions[0].bytesBase64Encoded) {
                            const imageUrl = `data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`;
                            generatedImageForDisplay = { data: imageUrl, mimeType: "image/png" };
                            generatedImageForHistory = { inlineData: { mimeType: "image/png", data: imageResult.predictions[0].bytesBase64Encoded } };
                        } else {
                            console.warn("No image generated or unexpected image response structure.");
                        }
                    } catch (imageError) {
                        console.error("Error generating image:", imageError);
                        displayErrorMessage(`Image generation failed: ${imageError.message}`);
                    }
                }

                // Remove the "Thinking..." bubble
                const loadingBubble = document.getElementById('loading-bubble');
                if (loadingBubble) {
                    loadingBubble.remove();
                }

                // Construct AI response parts for history and display
                const aiResponsePartsForHistory = [{ text: aiResponseText }];
                const aiResponseFilesForDisplay = [];
                if (generatedImageForHistory) {
                    aiResponsePartsForHistory.push(generatedImageForHistory);
                    aiResponseFilesForDisplay.push(generatedImageForDisplay);
                }

                // Add the AI's actual response as a new message with its first generation
                chatHistory.push({
                    role: "model",
                    generations: [{ parts: aiResponsePartsForHistory }],
                    currentGenerationIndex: 0
                });
                saveChatSessionsToStorage();
                
                // Add the AI's actual response to chat display (using the new structure)
                // The addMessageToChat function will now correctly display the first generation
                displayCurrentChatHistory(); // Re-render all to ensure generation UI is correct
                speakText(aiResponseText);

            } catch (error) {
                const errorMessageText = `Error: ${error.message || "Could not connect to AI."}`;
                // Remove the "Thinking..." bubble before displaying error in its place
                const loadingBubble = document.getElementById('loading-bubble');
                if (loadingBubble) {
                    loadingBubble.remove();
                }
                // Add error message as a new AI message (not a generation)
                chatHistory.push({
                    role: "model",
                    generations: [{ parts: [{ text: errorMessageText }] }],
                    currentGenerationIndex: 0
                });
                displayCurrentChatHistory(); // Re-render to show the error message
                displayErrorMessage(errorMessageText); // Display error in dedicated error div
            } finally {
                sendButton.disabled = false;
                if(micButton) micButton.disabled = geminiApiKey ? false : true;
                if(speakerToggleButton) speakerToggleButton.disabled = false;
                if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload button
                if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen button
                if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share button
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research button
                if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas button
                loadingIndicator.classList.add('hidden');
                loadingIndicator.textContent = "AI is thinking..."; // Reset loading text
                messageInput.focus();
                renderChatList(); // Re-render chat list to update names if first message was sent
            }
        }

        /**
         * Initiates editing a message.
         * @param {number} indexToEdit - The index of the message in chatHistory to edit.
         */
        function editMessage(indexToEdit) {
            const messageToEdit = chatHistory[indexToEdit];
            if (!messageToEdit || messageToEdit.role === 'system') return; // Cannot edit system messages

            const messageElement = chatMessages.querySelector(`[data-message-index="${indexToEdit}"]`);
            if (!messageElement) return;

            const textContentContainer = messageElement.querySelector('.message-text-content');
            const currentText = textContentContainer.textContent;

            // Create textarea for editing
            const textarea = document.createElement('textarea');
            textarea.classList.add('edit-textarea');
            textarea.value = currentText;
            textContentContainer.replaceWith(textarea); // Replace text content with textarea

            // Hide existing action buttons and delete button
            const actionsContainer = messageElement.querySelector('.message-actions');
            if (actionsContainer) actionsContainer.classList.add('hidden');
            const deleteButton = messageElement.querySelector('.delete-message-button');
            if (deleteButton) deleteButton.classList.add('hidden');

            // Create Save and Cancel buttons
            const editControls = document.createElement('div');
            editControls.classList.add('message-actions', 'edit-controls'); // Reuse message-actions for styling

            const saveButton = document.createElement('button');
            saveButton.classList.add('message-action-button', 'save-button');
            saveButton.textContent = 'Save';
            saveButton.addEventListener('click', () => saveEditedMessage(indexToEdit, textarea.value));
            editControls.appendChild(saveButton);

            const cancelButton = document.createElement('button');
            cancelButton.classList.add('message-action-button', 'cancel-button');
            cancelButton.textContent = 'Cancel';
            cancelButton.addEventListener('click', () => cancelEditMessage(indexToEdit, currentText));
            editControls.appendChild(cancelButton);

            // Add regenerate button if it's an AI message
            if (messageToEdit.role === 'model') {
                const regenerateButton = document.createElement('button');
                regenerateButton.classList.add('message-action-button', 'regenerate-button');
                regenerateButton.textContent = 'Regenerate';
                regenerateButton.addEventListener('click', () => showConfirmationModal('Regenerate Response', 'Are you sure you want to regenerate this AI response? This will delete all subsequent messages.', () => regenerateResponse(indexToEdit)));
                editControls.appendChild(regenerateButton);
            }


            messageElement.appendChild(editControls);
            textarea.focus();
            textarea.select();
        }

        /**
         * Saves the edited message content.
         * @param {number} indexToEdit - The index of the message in chatHistory that was edited.
         * @param {string} newText - The new text content for the message.
         */
        function saveEditedMessage(indexToEdit, newText) {
            const message = chatHistory[indexToEdit];
            if (!message) return;

            if (message.role === 'user') {
                const textPart = message.parts.find(p => p.text);
                if (textPart) {
                    textPart.text = newText.trim();
                } else {
                    message.parts.unshift({ text: newText.trim() });
                }
            } else if (message.role === 'model') {
                // Edit the current generation of the AI message
                const currentGeneration = message.generations[message.currentGenerationIndex];
                const textPart = currentGeneration.parts.find(p => p.text);
                if (textPart) {
                    textPart.text = newText.trim();
                } else {
                    currentGeneration.parts.unshift({ text: newText.trim() });
                }
            }

            saveChatSessionsToStorage();
            displayCurrentChatHistory(); // Re-render to show updated message and restore buttons
        }

        /**
         * Cancels the message editing and reverts to original content.
         * @param {number} indexToCancel - The index of the message in chatHistory where editing was cancelled.
         * @param {string} originalText - The original text content of the message.
         */
        function cancelEditMessage(indexToCancel, originalText) {
            // Simply re-render the chat history to discard changes
            displayCurrentChatHistory();
        }

        /**
         * Regenerates an AI response based on the preceding user message.
         * @param {number} aiMessageIndex - The index of the AI message to regenerate.
         */
        async function regenerateResponse(aiMessageIndex) {
            if (aiMessageIndex <= 0 || chatHistory[aiMessageIndex].role !== 'model') {
                displayErrorMessage("Cannot regenerate this message.");
                return;
            }

            const userPromptMessage = chatHistory[aiMessageIndex - 1];
            if (userPromptMessage.role !== 'user') {
                displayErrorMessage("Cannot regenerate: preceding message is not a user prompt.");
                return;
            }

            // Get the AI message object that we want to add a new generation to
            const aiMessageObject = chatHistory[aiMessageIndex];

            // Construct chat history for API call: up to and including the user prompt
            // This is the history that the AI will "see" before generating the new response.
            let chatHistoryForApi = chatHistory.slice(0, aiMessageIndex); // All messages BEFORE the AI message we are regenerating

            // Add prompt info from the current chat session
            const currentChat = chatSessions[currentChatId];
            const promptInfo = currentChat ? currentChat.promptInfo : '';
            if (promptInfo) {
                chatHistoryForApi.unshift({ role: "system", parts: [{ text: promptInfo }] });
            }

            // Get the selected model for the current chat
            const selectedModelForChat = currentChat ? currentChat.selectedModel : 'gemini-1.5-flash-latest';

            // Display "Thinking..." message
            loadingIndicator.classList.remove('hidden');
            loadingIndicator.textContent = "AI is thinking...";
            // We don't add a new "Thinking..." bubble here because we're modifying an existing one.
            // The existing AI message will remain on screen while we fetch a new generation.

            // Disable input and buttons
            sendButton.disabled = true;
            if(micButton) micButton.disabled = true;
            if(speakerToggleButton) speakerToggleButton.disabled = true;
            if(uploadButton) uploadButton.disabled = true;
            if(imageGenToggleButton) imageGenToggleButton.disabled = true;
            if(shareScreenButton) shareScreenButton.disabled = true;
            if(deepResearchToggleButton) deepResearchToggleButton.disabled = true;
            if(canvasToggleButton) canvasToggleButton.disabled = true;

            try {
                // Call Gemini for text response (using the truncated history up to the user's prompt)
                const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModelForChat}:generateContent?key=${geminiApiKey}`;
                const textPayload = { contents: formatChatHistoryForApi(chatHistoryForApi) };

                // Add temperature to generationConfig for varied responses
                textPayload.generationConfig = {
                    temperature: 0.9 // Higher temperature for more varied responses
                };

                const textResponse = await fetch(textApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(textPayload)
                });

                if (!textResponse.ok) {
                    const errorData = await textResponse.json();
                    let detailedError = `Text AI Error: ${textResponse.status}`;
                    if (errorData && errorData.error && errorData.error.message) detailedError += ` - ${errorData.error.message}`;
                    throw new Error(detailedError);
                }

                const textResult = await textResponse.json();
                let aiResponseText = "Sorry, I couldn't get a text response.";
                if (textResult.candidates && textResult.candidates[0]?.content?.parts?.[0]?.text) {
                    aiResponseText = textResult.candidates[0].content.parts[0].text;
                } else if (textResult.promptFeedback?.blockReason) {
                     aiResponseText = `Text response blocked: ${textResult.promptFeedback.blockReason}.`;
                }

                if (isDeepResearchEnabled) {
                    aiResponseText += "\n\n(Note: Deep Research is not available via the current API.)";
                }
                if (isCanvasEnabled) {
                    aiResponseText += "\n\n(Note: Canvas output is not available via the current API.)";
                }

                let generatedImageForDisplay = null;
                let generatedImageForHistory = null;
                const originalUserMessageText = userPromptMessage.parts.find(p => p.text)?.text || '';

                if (isImageGenerationEnabled && originalUserMessageText) {
                    loadingIndicator.textContent = "AI is generating image...";
                    try {
                        const imagePayload = { instances: { prompt: originalUserMessageText }, parameters: { "sampleCount": 1} };
                        const imageApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${geminiApiKey}`;

                        const imageResponse = await fetch(imageApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(imagePayload)
                        });

                        if (!imageResponse.ok) {
                            const errorData = await imageResponse.json();
                            throw new Error(`Image API Error: ${imageResponse.status} - ${errorData.error?.message || 'Unknown error'}`);
                        }

                        const imageResult = await imageResponse.json();
                        if (imageResult.predictions && imageResult.predictions.length > 0 && imageResult.predictions[0].bytesBase64Encoded) {
                            const imageUrl = `data:image/png;base64,${imageResult.predictions[0].bytesBase64Encoded}`;
                            generatedImageForDisplay = { data: imageUrl, mimeType: "image/png" };
                            generatedImageForHistory = { inlineData: { mimeType: "image/png", data: imageResult.predictions[0].bytesBase64Encoded } };
                        } else {
                            console.warn("No image generated or unexpected image response structure.");
                        }
                    } catch (imageError) {
                        console.error("Error generating image:", imageError);
                        displayErrorMessage(`Image generation failed: ${imageError.message}`);
                    }
                }

                // Construct new AI response parts for history
                const newAiResponseParts = [{ text: aiResponseText }];
                const newAiResponseFilesForDisplay = [];
                if (generatedImageForHistory) {
                    newAiResponseParts.push(generatedImageForHistory);
                    newAiResponseFilesForDisplay.push(generatedImageForDisplay);
                }

                // Add the new generation to the existing AI message object
                if (!aiMessageObject.generations) {
                    aiMessageObject.generations = [];
                }
                aiMessageObject.generations.push({ parts: newAiResponseParts });
                aiMessageObject.currentGenerationIndex = aiMessageObject.generations.length - 1; // Point to the new generation

                saveChatSessionsToStorage();
                displayCurrentChatHistory(); // Re-render to show the new generation
                speakText(aiResponseText);

            } catch (error) {
                const errorMessageText = `Error: ${error.message || "Could not connect to AI."}`;
                displayErrorMessage(errorMessageText);
                // If an error occurs during regeneration, we should still update the UI
                // to reflect that the attempt failed, perhaps by adding a new generation
                // with the error message, or by just displaying the error.
                // The current AI message will remain as it was before the regeneration attempt.
            } finally {
                sendButton.disabled = false;
                if(micButton) micButton.disabled = geminiApiKey ? false : true;
                if(speakerToggleButton) speakerToggleButton.disabled = false;
                if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true;
                if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true;
                if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true;
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true;
                if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true;
                loadingIndicator.classList.add('hidden');
                loadingIndicator.textContent = "AI is thinking...";
                messageInput.focus();
                renderChatList();
                hideConfirmationModal();
            }
        }

        /**
         * Switches the displayed generation for a specific AI message.
         * @param {number} messageIndex - The index of the AI message in chatHistory.
         * @param {number} newGenIndex - The index of the generation to display.
         */
        function switchGeneration(messageIndex, newGenIndex) {
            const messageObj = chatHistory[messageIndex];
            if (!messageObj || messageObj.role !== 'model' || !messageObj.generations || newGenIndex < 0 || newGenIndex >= messageObj.generations.length) {
                console.error("Invalid attempt to switch generation.");
                return;
            }

            messageObj.currentGenerationIndex = newGenIndex;
            saveChatSessionsToStorage();
            displayCurrentChatHistory(); // Re-render the entire chat to update the specific message
        }

        /**
         * Deletes a specific message from the current chat history.
         * This function is called after confirmation from the custom modal.
         * @param {number} indexToDelete - The index of the message to delete.
         */
        function deleteMessageConfirmed(indexToDelete) {
            if (indexToDelete >= 0 && indexToDelete < chatHistory.length) {
                chatHistory.splice(indexToDelete, 1);
                saveChatSessionsToStorage();
                displayCurrentChatHistory(); // Re-render chat to reflect deletion
            }
            hideConfirmationModal(); // Hide the modal after action
        }

        // --- Custom Confirmation Modal Functions ---
        let confirmCallback = null;

        /**
         * Displays the custom confirmation modal.
         * @param {string} title - The title for the confirmation modal.
         * @param {string} message - The message to display in the confirmation modal.
         * @param {Function} onConfirm - The callback function to execute if the user confirms.
         */
        function showConfirmationModal(title, message, onConfirm) {
            confirmationTitle.textContent = title;
            confirmationMessage.textContent = message;
            confirmCallback = onConfirm; // Store the callback
            confirmationModal.style.display = 'flex';
        }

        /**
         * Hides the custom confirmation modal.
         */
        function hideConfirmationModal() {
            confirmationModal.style.display = 'none';
            confirmCallback = null; // Clear the callback
        }

        // Event listeners for the custom confirmation modal
        confirmActionButton.addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback(); // Execute the stored callback
            }
        });

        cancelConfirmationButton.addEventListener('click', hideConfirmationModal);
        closeConfirmationModalButton.addEventListener('click', hideConfirmationModal);


        // --- Speech Recognition Control ---
        /**
         * Starts the speech recognition process.
         */
        function startRecording() {
            if (!recognition || !micButton) return;
            if (isRecording) return;

            try {
                isRecording = true;
                recognition.start();
                micIconIdle.classList.add('hidden');
                micIconActive.classList.remove('hidden');
                micButton.classList.add('mic-active');
                sendButton.disabled = true;
                if(uploadButton) uploadButton.disabled = true; // Disable upload during recording
                if(imageGenToggleButton) imageGenToggleButton.disabled = true; // Disable image gen during recording
                if(shareScreenButton) shareScreenButton.disabled = true; // Disable screen share during recording
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = true; // Disable deep research during recording
                if(canvasToggleButton) canvasToggleButton.disabled = true; // Disable canvas during recording
                messageInput.placeholder = "Listening...";
            } catch (e) {
                isRecording = false;
                if (e.name === 'InvalidStateError') displayErrorMessage("Mic busy or already started.");
                else displayErrorMessage("Could not start microphone.");
                micIconIdle.classList.remove('hidden');
                micIconActive.classList.add('hidden');
                micButton.classList.remove('mic-active');
                sendButton.disabled = geminiApiKey ? false : true;
                if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload
                if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen
                if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research
                if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas
                messageInput.placeholder = "Type or say your message...";
            }
        }

        /**
         * Stops the speech recognition process.
         */
        function stopRecording() {
            if (!recognition || !micButton) return;
            if (!isRecording) return;

            recognition.stop();
            isRecording = false;
            micIconIdle.classList.remove('hidden');
            micIconActive.classList.add('hidden');
            micButton.classList.remove('mic-active');
            sendButton.disabled = geminiApiKey ? false : true;
            if(uploadButton) uploadButton.disabled = geminiApiKey ? false : true; // Re-enable upload
            if(imageGenToggleButton) imageGenToggleButton.disabled = geminiApiKey ? false : true; // Re-enable image gen
            if(shareScreenButton) shareScreenButton.disabled = geminiApiKey ? false : true; // Re-enable screen share
            if(deepResearchToggleButton) deepResearchToggleButton.disabled = geminiApiKey ? false : true; // Re-enable deep research
            if(canvasToggleButton) canvasToggleButton.disabled = geminiApiKey ? false : true; // Re-enable canvas
            messageInput.placeholder = "Type or say your message...";
        }
        
        if(micButton) {
            micButton.addEventListener('click', () => {
                if (isRecording) stopRecording();
                else startRecording();
            });
        }


        // --- Settings Modal Functions ---
        /**
         * Opens the settings modal.
         */
        function openSettingsModal() {
            apiKeyInput.value = geminiApiKey;
            // Set checkbox states when opening modal
            if (toggleUploadButton) toggleUploadButton.checked = showUploadButton;
            if (toggleShareScreenButton) toggleShareScreenButton.checked = showShareScreenButton;
            if (toggleImageGenButton) toggleImageGenButton.checked = showImageGenButton;
            if (toggleDeepResearchButton) toggleDeepResearchButton.checked = showDeepResearchButton;
            if (toggleCanvasButton) toggleCanvasButton.checked = showCanvasButton;
            if (toggleMicButton) toggleMicButton.checked = showMicButton;
            if (toggleSpeakerButton) toggleSpeakerButton.checked = showSpeakerButton;
            if (toggleThinkingButton) toggleThinkingButton.checked = showThinkingButton;

            settingsModal.style.display = 'flex';
        }

        /**
         * Closes the settings modal.
         */
        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        /**
         * Saves the entered API key and feature visibility settings to local storage.
         */
        function saveSettings() {
            const newApiKey = apiKeyInput.value.trim();
            if (newApiKey) {
                geminiApiKey = newApiKey;
                localStorage.setItem('geminiApiKey', geminiApiKey);
                updateApiKeyStatus();
                apiKeyPrompt.classList.add('hidden');
                sendButton.disabled = false;
                if(micButton) micButton.disabled = false;
                if(uploadButton) uploadButton.disabled = false; // Enable upload button
                if(imageGenToggleButton) imageGenToggleButton.disabled = false; // Enable image gen button
                if(shareScreenButton) shareScreenButton.disabled = false; // Enable screen share button
                if(deepResearchToggleButton) deepResearchToggleButton.disabled = false; // Enable deep research
                if(canvasToggleButton) canvasToggleButton.disabled = false; // Enable canvas
                clearErrorMessage();
                addMessageToChat("API Key saved. You can now chat.", 'system');
            } else {
                apiKeyStatus.textContent = 'API Key cannot be empty.';
                apiKeyStatus.classList.remove('text-slate-500', 'dark:text-slate-400', 'text-green-600', 'dark:text-green-500');
                apiKeyStatus.classList.add('text-red-500', 'dark:text-red-400');
            }

            // Save feature visibility settings and update UI immediately
            showUploadButton = toggleUploadButton.checked;
            localStorage.setItem('showUploadButton', showUploadButton);

            showShareScreenButton = toggleShareScreenButton.checked;
            localStorage.setItem('showShareScreenButton', showShareScreenButton);

            showImageGenButton = toggleImageGenButton.checked;
            localStorage.setItem('showImageGenButton', showImageGenButton);

            showDeepResearchButton = toggleDeepResearchButton.checked;
            localStorage.setItem('showDeepResearchButton', showDeepResearchButton); // Corrected: Use showDeepResearchButton
            localStorage.setItem('isDeepResearchEnabled', isDeepResearchEnabled); // Keep this for actual feature state

            showCanvasButton = toggleCanvasButton.checked;
            localStorage.setItem('showCanvasButton', showCanvasButton);

            showMicButton = toggleMicButton.checked;
            localStorage.setItem('showMicButton', showMicButton);

            showSpeakerButton = toggleSpeakerButton.checked;
            localStorage.setItem('showSpeakerButton', showSpeakerButton);

            showThinkingButton = toggleThinkingButton.checked;
            localStorage.setItem('showThinkingButton', showThinkingButton);


            updateButtonVisibilityUI(); // Apply visibility changes immediately
            displayCurrentChatHistory(); // Re-render chat messages to apply "Show Thinking" button visibility
            closeSettingsModal();
        }
        
        /**
         * Updates the API key status message in the settings modal.
         */
        function updateApiKeyStatus() {
            if (geminiApiKey) {
                apiKeyStatus.textContent = 'API Key is set.';
                apiKeyStatus.classList.remove('text-red-500', 'dark:text-red-400');
                apiKeyStatus.classList.add('text-green-600', 'dark:text-green-500');
            } else {
                apiKeyStatus.textContent = 'API Key is not set.';
                apiKeyStatus.classList.remove('text-green-600', 'dark:text-green-500');
                apiKeyStatus.classList.add('text-red-500', 'dark:text-red-400');
            }
        }

        // --- Chat Session Management ---

        /**
         * Generates a unique ID for a new chat session.
         * @returns {string} A unique ID.
         */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        /**
         * Saves all chat sessions to local storage.
         */
        function saveChatSessionsToStorage() {
            try {
                localStorage.setItem('geminiChatSessions', JSON.stringify(chatSessions));
                localStorage.setItem('currentChatId', currentChatId); // Save current chat ID
            } catch (e) {
                console.warn("Could not save chat sessions:", e);
            }
        }

        /**
         * Loads all chat sessions from local storage.
         */
        function loadChatSessionsFromStorage() {
            const storedSessions = localStorage.getItem('geminiChatSessions');
            if (storedSessions) {
                try {
                    const parsedSessions = JSON.parse(storedSessions);
                    if (typeof parsedSessions === 'object' && parsedSessions !== null) {
                        for (const id in parsedSessions) {
                            const session = parsedSessions[id];
                            // Adapt old structure (array of messages) to new structure
                            if (Array.isArray(session)) { // Old format: chatSessions[id] was just the history array
                                chatSessions[id] = { history: [], name: `Chat ${Object.keys(chatSessions).length + 1}`, profilePicture: '', promptInfo: '', selectedModel: 'gemini-1.5-flash-latest' };
                                session.forEach(msg => {
                                    if (msg.role === 'model' && !msg.generations) { // If old AI message without generations
                                        chatSessions[id].history.push({
                                            role: 'model',
                                            generations: [{ parts: msg.parts }],
                                            currentGenerationIndex: 0
                                        });
                                    } else {
                                        chatSessions[id].history.push(msg); // User messages or already new AI messages
                                    }
                                });
                            } else { // New format: chatSessions[id] is an object
                                chatSessions[id] = session;
                                // Ensure name, profilePicture, promptInfo, selectedModel exist for existing chats
                                if (!chatSessions[id].name) {
                                    chatSessions[id].name = `Chat ${Object.keys(chatSessions).length + 1}`;
                                }
                                if (!chatSessions[id].profilePicture) {
                                    chatSessions[id].profilePicture = '';
                                }
                                if (!chatSessions[id].promptInfo) {
                                    chatSessions[id].promptInfo = '';
                                }
                                if (!chatSessions[id].selectedModel) {
                                    chatSessions[id].selectedModel = 'gemini-1.5-flash-latest'; // Default model
                                }
                                // Ensure all AI messages within history have generations and currentGenerationIndex
                                chatSessions[id].history = chatSessions[id].history.map(msg => {
                                    if (msg.role === 'model' && !msg.generations) {
                                        return {
                                            role: 'model',
                                            generations: [{ parts: msg.parts }],
                                            currentGenerationIndex: 0
                                        };
                                    }
                                    // Ensure currentGenerationIndex is set for existing generations if missing
                                    if (msg.role === 'model' && msg.generations && msg.currentGenerationIndex === undefined) {
                                        msg.currentGenerationIndex = 0;
                                    }
                                    return msg;
                                });
                            }
                        }
                    } else {
                        localStorage.removeItem('geminiChatSessions');
                        chatSessions = {};
                    }
                } catch (e) {
                    console.error("Error parsing stored chat sessions:", e);
                    localStorage.removeItem('geminiChatSessions'); // Clear corrupted data
                    chatSessions = {};
                }
            }

            // If no sessions exist or parsing failed, create a default one
            if (Object.keys(chatSessions).length === 0) {
                startNewChat(false, true); // Start a new chat AND show customize modal
            } else {
                // Set currentChatId to the last active one or the first available chat
                currentChatId = localStorage.getItem('currentChatId') || Object.keys(chatSessions)[0];
                // Fallback if the stored currentChatId no longer exists
                if (!chatSessions[currentChatId]) {
                    currentChatId = Object.keys(chatSessions)[0];
                }
                chatHistory = chatSessions[currentChatId].history || []; // Access history property
            }
            renderChatList();
        }

        /**
         * Displays the messages of the current chat history in the chat messages area.
         */
        function displayCurrentChatHistory() {
            chatMessages.innerHTML = ''; // Clear existing messages
            chatHistory.forEach((item, index) => {
                let messageText = '';
                const filesToDisplay = [];
                let totalGenerations = 1;
                let currentGenIndex = 0;

                if (item.role === 'model') {
                    totalGenerations = item.generations ? item.generations.length : 1;
                    currentGenIndex = item.currentGenerationIndex !== undefined ? item.currentGenerationIndex : 0;
                    const partsToDisplay = item.generations?.[currentGenIndex]?.parts || [{ text: "No content available." }];
                    partsToDisplay.forEach(part => {
                        if (part.text) {
                            messageText += part.text;
                        } else if (part.inlineData) {
                            filesToDisplay.push({
                                data: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
                                mimeType: part.inlineData.mimeType
                            });
                        }
                    });
                } else { // user or system message
                    item.parts.forEach(part => {
                        if (part.text) {
                            messageText += part.text;
                        } else if (part.inlineData) {
                            filesToDisplay.push({
                                data: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
                                mimeType: part.inlineData.mimeType
                            });
                        }
                    });
                }
                addMessageToChat(messageText, item.role === 'user' ? 'user' : 'ai', false, filesToDisplay, index, totalGenerations, currentGenIndex);
            });
            chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom
        }


        /**
         * Renders (or re-renders) the list of chat sessions in the sidebar.
         */
        function renderChatList() {
            chatListContainer.innerHTML = ''; // Clear existing list items
            const chatIds = Object.keys(chatSessions).sort((a, b) => {
                // Sort by creation time (assuming IDs are timestamp-based)
                return parseInt(a.substring(0, a.indexOf('.')), 36) - parseInt(b.substring(0, b.indexOf('.')), 36);
            });

            if (chatIds.length === 0) {
                // If no chats, ensure a new one is created
                startNewChat(false, true); // Create and immediately show customize modal
                return;
            }

            chatIds.forEach((chatId, index) => {
                const chatItem = document.createElement('div');
                chatItem.classList.add(
                    'chat-list-item',
                    'flex', 'items-center', 'justify-between', 'p-3', 'rounded-lg', 'cursor-pointer',
                    'hover:bg-slate-200', 'dark:hover:bg-slate-700', 'transition-colors', 'duration-150',
                    'text-slate-700', 'dark:text-slate-200'
                );
                if (chatId === currentChatId) {
                    chatItem.classList.add('active');
                }
                chatItem.dataset.chatId = chatId;

                // Determine chat name: stored name, first user message, first AI response, or generic
                let chatName = chatSessions[chatId].name;
                const history = chatSessions[chatId].history;

                if (!chatName || chatName.startsWith('Chat ')) { // If no custom name or generic name
                    if (history && history.length > 0) {
                        const firstUserMessagePart = history.find(msg => msg.role === 'user')?.parts.find(part => part.text);
                        const firstAiResponsePart = history.find(msg => msg.role === 'model')?.generations?.[0]?.parts.find(part => part.text); // Check first generation
                        if (firstUserMessagePart) {
                            chatName = firstUserMessagePart.text.substring(0, 30) + (firstUserMessagePart.text.length > 30 ? '...' : '');
                        } else if (firstAiResponsePart) {
                            chatName = firstAiResponsePart.text.substring(0, 30) + (firstAiResponsePart.text.length > 30 ? '...' : '');
                        } else {
                            chatName = `Chat ${index + 1}`;
                        }
                    } else {
                        chatName = `Chat ${index + 1}`;
                    }
                    chatSessions[chatId].name = chatName; // Update name in session data
                }
                
                const chatNameSpan = document.createElement('span');
                chatNameSpan.textContent = chatName;
                chatNameSpan.classList.add('flex-1', 'truncate'); // Ensure text truncates if too long

                // Add profile picture to chat list item
                const chatProfilePic = document.createElement('img');
                chatProfilePic.classList.add('w-8', 'h-8', 'rounded-full', 'object-cover', 'mr-2', 'flex-shrink-0');
                chatProfilePic.src = chatSessions[chatId].profilePicture || 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Default or stored
                chatProfilePic.alt = 'Chat Profile';


                const buttonsContainer = document.createElement('div');
                buttonsContainer.classList.add('flex', 'items-center', 'space-x-1', 'ml-2');

                // Customize button (replaces rename)
                const customizeButton = document.createElement('button');
                customizeButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 text-slate-400 hover:text-blue-500 dark:hover:text-blue-400">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14.25v4.5a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 18V7.5a2.25 2.25 0 0 1 2.25-2.25h4.5" />
                    </svg>
                `;
                customizeButton.classList.add('w-6', 'h-6', 'p-1', 'rounded-full', 'hover:bg-slate-300', 'dark:hover:bg-slate-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'flex', 'items-center', 'justify-center');
                customizeButton.title = "Customize Chat";
                customizeButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent switching chat when customizing
                    openCustomizeChatModal(chatId);
                });
                buttonsContainer.appendChild(customizeButton);


                const deleteButton = document.createElement('button');
                // Simple 'X' icon for delete
                deleteButton.innerHTML = `
                    <span class="text-base leading-none text-slate-400 hover:text-red-500 dark:hover:text-red-400">&times;</span>
                `;
                // Adjusted w-6 h-6 and text-base for better visual alignment
                deleteButton.classList.add('w-6', 'h-6', 'p-1', 'rounded-full', 'hover:bg-slate-300', 'dark:hover:bg-slate-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-red-500', 'flex', 'items-center', 'justify-center');
                deleteButton.title = "Delete Chat";
                deleteButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent switching chat when deleting
                    showConfirmationModal('Delete Chat', 'Are you sure you want to delete this chat?', () => deleteChatConfirmed(chatId));
                });
                buttonsContainer.appendChild(deleteButton);

                chatItem.appendChild(chatProfilePic); // Add profile picture to the left
                chatItem.appendChild(chatNameSpan);
                chatItem.appendChild(buttonsContainer); // Append the container with both buttons
                chatItem.addEventListener('click', () => switchChat(chatId));
                chatListContainer.appendChild(chatItem);
            });
        }

        /**
         * Starts a new chat session.
         * @param {boolean} [savePrevious=true] - Whether to save the current chat before starting a new one.
         * @param {boolean} [openCustomizeModal=false] - Whether to open the customize modal immediately after creating.
         */
        function startNewChat(savePrevious = true, openCustomizeModalAfterCreation = false) {
            if (savePrevious && currentChatId && chatSessions[currentChatId]) {
                // Ensure the current chat's history is saved before switching
                chatSessions[currentChatId].history = chatHistory; // Save history
            }

            const newId = generateUniqueId();
            const newChatName = `Chat ${Object.keys(chatSessions).length + 1}`;
            // Initialize with empty history, default name, no picture, no prompt, and default model
            chatSessions[newId] = { history: [], name: newChatName, profilePicture: '', promptInfo: '', selectedModel: 'gemini-1.5-flash-latest' }; 
            currentChatId = newId; 
            chatHistory = chatSessions[currentChatId].history; // Update reference to new chat's history

            saveChatSessionsToStorage();
            displayCurrentChatHistory(); // Clear and display empty chat
            addMessageToChat("Welcome! How can I help you today?", 'system');
            messageInput.value = ''; // Clear input field
            messageInput.focus();
            selectedFiles = []; // Clear any pending selected files
            uploadedFilesPreview.innerHTML = ''; // Clear preview UI
            uploadedFilesPreview.classList.add('hidden'); // Hide preview container
            renderChatList(); // Re-render list to show new chat and highlight it
            updateCurrentModelDisplay(); // Update header model display

            if (openCustomizeModalAfterCreation) {
                openCustomizeChatModal(newId);
            }
        }

        /**
         * Switches the current chat session to the specified chatId.
         * @param {string} chatId - The ID of the chat session to switch to.
         */
        function switchChat(chatId) {
            if (chatId === currentChatId) return; // Already on this chat

            // Save the current chat's history before switching
            if (currentChatId && chatSessions[currentChatId]) {
                chatSessions[currentChatId].history = chatHistory; // Save history
            }

            currentChatId = chatId;
            chatHistory = chatSessions[currentChatId].history; // Update reference to new chat's history
            saveChatSessionsToStorage(); // Save updated currentChatId

            displayCurrentChatHistory(); // Display messages of the new chat
            renderChatList(); // Update active state in the list
            messageInput.focus();
            selectedFiles = []; // Clear any pending selected files
            uploadedFilesPreview.innerHTML = ''; // Clear preview UI
            uploadedFilesPreview.classList.add('hidden'); // Hide preview container
            updateCurrentModelDisplay(); // Update header model display
        }

        /**
         * Deletes a chat session by its ID.
         * This function is called after confirmation from the custom modal.
         * @param {string} chatIdToDelete - The ID of the chat session to delete.
         */
        function deleteChatConfirmed(chatIdToDelete) {
            delete chatSessions[chatIdToDelete];
            saveChatSessionsToStorage();

            if (chatIdToDelete === currentChatId) {
                // If the deleted chat was the current one, switch to another or create new
                const remainingChatIds = Object.keys(chatSessions);
                if (remainingChatIds.length > 0) {
                    switchChat(remainingChatIds[0]); // Switch to the first remaining chat
                } else {
                    startNewChat(false, true); // No chats left, start a brand new one and open customize modal
                }
            }
            renderChatList(); // Re-render the list after deletion
            hideConfirmationModal(); // Hide the modal after action
        }

        // --- File Upload Functions ---
        /**
         * Handles the selection of files from the file input.
         * @param {Event} event - The change event from the file input.
         */
        function handleFileSelection(event) {
            selectedFiles = []; // Clear previous selections
            uploadedFilesPreview.innerHTML = ''; // Clear previous previews
            uploadedFilesPreview.classList.add('hidden');

            const files = event.target.files;
            if (files.length === 0) return;

            // Limit to 1 image for simplicity with Gemini API, or handle multiple images if needed
            if (files.length > 1) {
                displayErrorMessage("Only one image can be uploaded at a time.");
                fileInput.value = ''; // Clear the input
                return;
            }

            const file = files[0];
            if (!file.type.startsWith('image/')) {
                displayErrorMessage("Only image files are supported.");
                fileInput.value = ''; // Clear the input
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                // Store the full data URL for display purposes
                const fullDataUrl = e.target.result; 
                selectedFiles.push({
                    data: fullDataUrl, // Store full data URL
                    mimeType: file.type
                });
                displaySelectedFiles();
            };
            reader.onerror = (error) => {
                console.error("Error reading file:", error);
                displayErrorMessage("Failed to read file.");
            };
            reader.readAsDataURL(file);
        }

        /**
         * Displays the selected files as previews in the UI.
         */
        function displaySelectedFiles() {
            uploadedFilesPreview.innerHTML = '';
            if (selectedFiles.length > 0) {
                uploadedFilesPreview.classList.remove('hidden');
                selectedFiles.forEach((file, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.classList.add('relative', 'w-24', 'h-24', 'rounded-md', 'overflow-hidden', 'shadow-md');

                    const img = document.createElement('img');
                    img.src = file.data; // Use the full data URL
                    img.alt = `Preview ${index}`;
                    img.classList.add('w-full', 'h-full', 'object-cover');

                    const removeButton = document.createElement('button');
                    removeButton.classList.add(
                        'absolute', 'top-1', 'right-1', 'bg-red-500', 'text-white', 'rounded-full',
                        'w-6', 'h-6', 'flex', 'items-center', 'justify-center', 'text-xs', 'font-bold',
                        'hover:bg-red-600', 'focus:outline-none', 'focus:ring-2', 'focus:ring-red-400'
                    );
                    removeButton.textContent = 'X';
                    removeButton.title = 'Remove image';
                    removeButton.addEventListener('click', () => removeFile(index));

                    previewItem.appendChild(img);
                    previewItem.appendChild(removeButton);
                    uploadedFilesPreview.appendChild(previewItem);
                });
            } else {
                uploadedFilesPreview.classList.add('hidden');
            }
        }

        /**
         * Removes a file from the selectedFiles array and updates the preview.
         * @param {number} index - The index of the file to remove.
         */
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            fileInput.value = ''; // Clear the file input so same file can be re-selected
            displaySelectedFiles();
        }

        // --- Screen Sharing Functions ---
        /**
         * Starts screen sharing and begins capturing frames.
         */
        async function startScreenSharing() {
            if (isScreenSharingActive) return;

            try {
                // Request screen sharing with video only (audio handled by mic button)
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                
                isScreenSharingActive = true;
                updateScreenShareButtonUI();
                addMessageToChat("Screen sharing started. AI will analyze frames from your screen.", 'system');

                // Automatically enable microphone and AI voice
                if (!isRecording) {
                    startRecording(); // This will also update mic button UI
                }
                if (!aiVoiceEnabled) {
                    aiVoiceEnabled = true;
                    localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                    updateSpeakerButtonUI();
                }

                screenVideo.srcObject = screenStream;
                screenVideo.play();

                // Set canvas dimensions to match video stream
                screenVideo.onloadedmetadata = () => {
                    screenCanvas.width = screenVideo.videoWidth;
                    screenCanvas.height = screenVideo.videoHeight;
                };

                // Capture a frame every 5 seconds
                screenCaptureInterval = setInterval(() => {
                    if (screenVideo.videoWidth === 0 || screenVideo.videoHeight === 0) return; // Ensure video is ready
                    const context = screenCanvas.getContext('2d');
                    context.drawImage(screenVideo, 0, 0, screenCanvas.width, screenCanvas.height);
                    latestScreenBase64 = screenCanvas.toDataURL('image/jpeg'); // Store as JPEG Base64
                    // console.log("Captured screen frame:", latestScreenBase64.substring(0, 50) + "...");
                }, 5000); // Capture every 5 seconds

                // Listen for when the user stops sharing via browser controls
                screenStream.oninactive = () => {
                    stopScreenSharing();
                };

            } catch (error) {
                isScreenSharingActive = false;
                updateScreenShareButtonUI();
                if (error.name === 'NotAllowedError') {
                    displayErrorMessage("Screen sharing permission denied.");
                } else if (error.name === 'NotFoundError') {
                    displayErrorMessage("No display source found. Please ensure you have a screen or window to share.");
                } else {
                    displayErrorMessage(`Error starting screen sharing: ${error.message}`);
                }
                console.error("Error starting screen sharing:", error);
            }
        }

        /**
         * Stops screen sharing and clears resources.
         */
        function stopScreenSharing() {
            if (!isScreenSharingActive) return;

            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
                screenVideo.srcObject = null;
            }
            if (screenCaptureInterval) {
                clearInterval(screenCaptureInterval);
                screenCaptureInterval = null;
            }
            latestScreenBase64 = null;
            isScreenSharingActive = false;
            updateScreenShareButtonUI();
            addMessageToChat("Screen sharing stopped.", 'system');

            // Disable microphone and AI voice if they were enabled by screen sharing
            // Note: This simple implementation will turn them off regardless of manual user toggle.
            if (isRecording) {
                stopRecording();
            }
            if (aiVoiceEnabled) {
                aiVoiceEnabled = false;
                localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                updateSpeakerButtonUI();
                if (synth.speaking) synth.cancel();
            }
        }

        // --- Customize Chat Modal Functions ---
        let chatToCustomizeId = null; // Stores the ID of the chat being customized

        /**
         * Fetches available AI models from the Gemini API and populates the dropdown.
         */
        async function fetchAvailableModels() {
            if (!geminiApiKey) {
                modelSelectStatus.textContent = 'API Key is required to fetch models.';
                modelSelectStatus.classList.remove('hidden');
                aiModelSelect.innerHTML = '<option value="">(No models available)</option>';
                aiModelSelect.disabled = true;
                return;
            }

            modelSelectStatus.textContent = 'Fetching models...';
            modelSelectStatus.classList.remove('hidden', 'text-red-500', 'dark:text-red-400');
            modelSelectStatus.classList.add('text-slate-500', 'dark:text-slate-400');
            aiModelSelect.disabled = true;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${geminiApiKey}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Failed to fetch models: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }
                const data = await response.json();
                
                availableAiModels = data.models
                    .filter(model => model.name.startsWith('models/gemini-') && model.supportedGenerationMethods.includes('generateContent'))
                    .map(model => ({
                        id: model.name.replace('models/', ''),
                        displayName: model.displayName || model.name.replace('models/', '')
                    }))
                    .sort((a, b) => a.displayName.localeCompare(b.displayName));

                populateModelSelectDropdown();
                modelSelectStatus.classList.add('hidden'); // Hide status on success
                aiModelSelect.disabled = false;

            } catch (error) {
                console.error("Error fetching available models:", error);
                modelSelectStatus.textContent = `Error fetching models: ${error.message}`;
                modelSelectStatus.classList.remove('hidden', 'text-slate-500', 'dark:text-slate-400');
                modelSelectStatus.classList.add('text-red-500', 'dark:text-red-400');
                aiModelSelect.innerHTML = '<option value="">(Error loading models)</option>';
                aiModelSelect.disabled = true;
            }
        }

        /**
         * Populates the AI model select dropdown with available models.
         */
        function populateModelSelectDropdown() {
            aiModelSelect.innerHTML = ''; // Clear existing options

            if (availableAiModels.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '(No models available)';
                aiModelSelect.appendChild(option);
                aiModelSelect.disabled = true;
                return;
            }

            availableAiModels.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.displayName;
                aiModelSelect.appendChild(option);
            });

            // Set the selected value based on the current chat's model
            if (chatToCustomizeId && chatSessions[chatToCustomizeId]) {
                aiModelSelect.value = chatSessions[chatToCustomizeId].selectedModel || 'gemini-1.5-flash-latest';
            } else {
                aiModelSelect.value = 'gemini-1.5-flash-latest'; // Default if no chat selected or new chat
            }
            aiModelSelect.disabled = false;
        }

        /**
         * Opens the customize chat modal for a specific chat.
         * @param {string} chatId The ID of the chat to customize.
         */
        function openCustomizeChatModal(chatId) {
            chatToCustomizeId = chatId;
            const chat = chatSessions[chatId];

            if (!chat) {
                console.error("Chat not found for customization:", chatId);
                return;
            }

            chatNameInput.value = chat.name || '';
            chatPromptInfoTextarea.value = chat.promptInfo || '';
            
            // Set profile picture preview and button visibility
            if (chat.profilePicture) {
                chatProfilePicturePreview.src = chat.profilePicture;
                removeProfilePictureButton.classList.remove('hidden');
            } else {
                chatProfilePicturePreview.src = 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Default
                removeProfilePictureButton.classList.add('hidden');
            }

            // Set model select value and fetch models
            aiModelSelect.value = chat.selectedModel || 'gemini-1.5-flash-latest';
            fetchAvailableModels(); // Fetch and populate models when modal opens
            
            customizeChatModal.style.display = 'flex';
        }

        /**
         * Closes the customize chat modal.
         */
        function closeCustomizeChatModal() {
            customizeChatModal.style.display = 'none';
            chatToCustomizeId = null; // Clear the ID
            chatProfilePictureInput.value = ''; // Clear file input
        }

        /**
         * Saves the customized chat details.
         */
        function saveCustomizeChat() {
            if (!chatToCustomizeId) return;

            const chat = chatSessions[chatToCustomizeId];
            if (!chat) return;

            chat.name = chatNameInput.value.trim();
            chat.promptInfo = chatPromptInfoTextarea.value.trim();
            chat.selectedModel = aiModelSelect.value; // Save selected model
            // Profile picture is handled by its own event listener on file input

            saveChatSessionsToStorage();
            renderChatList(); // Re-render chat list to show updated name/picture
            updateCurrentModelDisplay(); // Update header model display
            closeCustomizeChatModal();
        }

        /**
         * Handles selecting a profile picture for the chat.
         * @param {Event} event The change event from the file input.
         */
        function handleProfilePictureSelection(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                displayErrorMessage("Only image files are supported for profile pictures.");
                chatProfilePictureInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                chatProfilePicturePreview.src = e.target.result;
                removeProfilePictureButton.classList.remove('hidden');
                if (chatToCustomizeId) {
                    chatSessions[chatToCustomizeId].profilePicture = e.target.result;
                    saveChatSessionsToStorage();
                    renderChatList(); // Update the list immediately
                }
            };
            reader.onerror = (error) => {
                console.error("Error reading profile picture file:", error);
                displayErrorMessage("Failed to read profile picture file.");
            };
            reader.readAsDataURL(file);
        }

        /**
         * Removes the profile picture from the current chat.
         */
        function removeProfilePicture() {
            chatProfilePicturePreview.src = 'https://placehold.co/64x64/e2e8f0/64748b?text=AI'; // Set to default
            removeProfilePictureButton.classList.add('hidden');
            chatProfilePictureInput.value = ''; // Clear the file input
            if (chatToCustomizeId) {
                chatSessions[chatToCustomizeId].profilePicture = ''; // Remove from data
                saveChatSessionsToStorage();
                renderChatList(); // Update the list immediately
            }
        }

        /**
         * Updates the model display in the header.
         */
        function updateCurrentModelDisplay() {
            if (currentChatId && chatSessions[currentChatId]) {
                currentModelDisplay.textContent = `(Model: ${chatSessions[currentChatId].selectedModel || 'gemini-1.5-flash-latest'})`;
            } else {
                currentModelDisplay.textContent = '(Model: gemini-1.5-flash-latest)'; // Default if no chat selected
            }
        }


        // --- Event Listeners ---
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !isRecording) sendMessage();
        });

        settingsButton.addEventListener('click', openSettingsModal);
        closeModalButton.addEventListener('click', closeSettingsModal);
        saveApiKeyButton.addEventListener('click', saveSettings); 
        openSettingsFromPromptButton.addEventListener('click', openSettingsModal);
        
        if(speakerToggleButton) {
            speakerToggleButton.addEventListener('click', () => {
                aiVoiceEnabled = !aiVoiceEnabled;
                localStorage.setItem('aiVoiceEnabled', aiVoiceEnabled);
                updateSpeakerButtonUI();
                if (!aiVoiceEnabled && synth.speaking) synth.cancel();
            });
        }

        if(voiceSelectDropdown) {
            voiceSelectDropdown.addEventListener('change', (event) => {
                selectedVoiceURI = event.target.value;
                localStorage.setItem('selectedVoiceURI', selectedVoiceURI);
            });
        }

        if (imageGenToggleButton) {
            imageGenToggleButton.addEventListener('click', () => {
                isImageGenerationEnabled = !isImageGenerationEnabled;
                localStorage.setItem('isImageGenerationEnabled', isImageGenerationEnabled);
                updateImageGenButtonUI();
            });
        }

        if (shareScreenButton) {
            shareScreenButton.addEventListener('click', () => {
                if (isScreenSharingActive) {
                    stopScreenSharing();
                } else {
                    startScreenSharing();
                }
            });
        }

        if (deepResearchToggleButton) {
            deepResearchToggleButton.addEventListener('click', () => {
                isDeepResearchEnabled = !isDeepResearchEnabled;
                localStorage.setItem('isDeepResearchEnabled', isDeepResearchEnabled);
                updateDeepResearchButtonUI();
            });
        }

        if (canvasToggleButton) {
            canvasToggleButton.addEventListener('click', () => {
                isCanvasEnabled = !isCanvasEnabled;
                localStorage.setItem('isCanvasEnabled', isCanvasEnabled);
                updateCanvasButtonUI();
            });
        }

        window.addEventListener('click', (event) => {
            if (event.target === settingsModal) closeSettingsModal();
            if (event.target === confirmationModal) hideConfirmationModal(); // Close confirmation modal on outside click
            if (event.target === customizeChatModal) closeCustomizeChatModal(); // Close customize chat modal on outside click
        });

        newChatButton.addEventListener('click', () => startNewChat(true, true)); // Pass true to open customize modal

        // File upload event listeners
        uploadButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelection);
        
        // Event listeners for new feature visibility toggles
        if (toggleUploadButton) {
            toggleUploadButton.addEventListener('change', () => {
                showUploadButton = toggleUploadButton.checked;
                localStorage.setItem('showUploadButton', showUploadButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleShareScreenButton) {
            toggleShareScreenButton.addEventListener('change', () => {
                showShareScreenButton = toggleShareScreenButton.checked;
                localStorage.setItem('showShareScreenButton', showShareScreenButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleImageGenButton) {
            toggleImageGenButton.addEventListener('change', () => {
                showImageGenButton = toggleImageGenButton.checked;
                localStorage.setItem('showImageGenButton', showImageGenButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleDeepResearchButton) {
            toggleDeepResearchButton.addEventListener('change', () => {
                showDeepResearchButton = toggleDeepResearchButton.checked;
                localStorage.setItem('showDeepResearchButton', showDeepResearchButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleCanvasButton) {
            toggleCanvasButton.addEventListener('change', () => {
                showCanvasButton = toggleCanvasButton.checked;
                localStorage.setItem('showCanvasButton', showCanvasButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleMicButton) {
            toggleMicButton.addEventListener('change', () => {
                showMicButton = toggleMicButton.checked;
                localStorage.setItem('showMicButton', showMicButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleSpeakerButton) {
            toggleSpeakerButton.addEventListener('change', () => {
                showSpeakerButton = toggleSpeakerButton.checked;
                localStorage.setItem('showSpeakerButton', showSpeakerButton);
                updateButtonVisibilityUI();
            });
        }
        if (toggleThinkingButton) {
            toggleThinkingButton.addEventListener('change', () => {
                showThinkingButton = toggleThinkingButton.checked;
                localStorage.setItem('showThinkingButton', showThinkingButton);
                updateButtonVisibilityUI();
                displayCurrentChatHistory(); // Re-render chat messages to apply "Show Thinking" button visibility
            });
        }

        // Customize Chat Modal Event Listeners
        closeCustomizeModalButton.addEventListener('click', closeCustomizeChatModal);
        cancelCustomizeChatButton.addEventListener('click', closeCustomizeChatModal);
        saveCustomizeChatButton.addEventListener('click', saveCustomizeChat);
        selectProfilePictureButton.addEventListener('click', () => chatProfilePictureInput.click());
        chatProfilePictureInput.addEventListener('change', handleProfilePictureSelection);
        removeProfilePictureButton.addEventListener('click', removeProfilePicture);


        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
